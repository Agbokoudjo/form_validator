<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form Validator Documentation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        header {
            background-color: #333;
            color: #fff;
            padding: 1rem 0;
            text-align: center;
        }

        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
            padding: 20px 0;
        }

        nav {
            float: left;
            width: 20%;
            background: #eee;
            padding: 15px;
            box-sizing: border-box;
            border-right: 1px solid #ddd;
        }

        nav h2 {
            color: #333;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ccc;
        }

        nav ul {
            list-style: none;
            padding: 0;
        }

        nav ul li a {
            display: block;
            padding: 8px 0;
            color: #007bff;
            text-decoration: none;
        }

        nav ul li a:hover {
            text-decoration: underline;
        }

        main {
            float: right;
            width: 80%;
            padding: 0 20px;
            box-sizing: border-box;
        }

        section {
            background: #fff;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3 {
            color: #007bff;
        }

        pre {
            background: #e9e9e9;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #e9e9e9;
            padding: 2px 4px;
            border-radius: 3px;
        }

        ul {
            list-style-type: disc;
            margin-left: 20px;
        }

        a {
            color: #007bff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .author-info {
            font-style: italic;
            color: #666;
            margin-bottom: 15px;
        }

        /* Horizontal rule styling */
        hr {
            border: 0;
            height: 1px;
            background: #ddd;
            margin: 20px 0;
        }
        .styled-table {
    width: 100%; /* Le tableau prend toute la largeur disponible */
    border-collapse: collapse; /* Fusionne les bordures des cellules */
    margin: 25px 0; /* Marge au-dessus et en-dessous du tableau */
    font-size: 0.9em;
    min-width: 400px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.15); /* Une légère ombre */
}

.styled-table thead tr {
    background-color: #009879; /* Couleur d'arrière-plan pour l'en-tête */
    color: #ffffff; /* Couleur du texte de l'en-tête */
    text-align: left; /* Alignement du texte à gauche */
}

.styled-table th,
.styled-table td {
    padding: 12px 15px; /* Espacement interne des cellules */
    border: 1px solid #dddddd; /* Bordure des cellules */
}

.styled-table tbody tr {
    border-bottom: 1px solid #dddddd; /* Bordure inférieure des lignes du corps */
}

.styled-table tbody tr:nth-of-type(even) { /* Style pour les lignes paires (rayures de zèbre) */
    background-color: #f3f3f3;
}

.styled-table tbody tr:last-of-type { /* Style pour la dernière ligne */
    border-bottom: 2px solid #009879;
}

.styled-table tbody tr.active-row { /* Exemple de classe pour une ligne active */
    font-weight: bold;
    color: #009879;
}

.styled-table tbody tr:hover { /* Effet de survol sur les lignes */
    background-color: #ddd;
    cursor: pointer;
}
section#fqdn-options {
  padding: 2rem;
  margin: 2rem auto;
  max-width: 900px;
  border: 1px solid #ddd;
  border-radius: 8px;
  background-color: #fefefe;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
}

section#fqdn-options h2 {
  font-size: 1.8rem;
  color: #2a3f54;
  margin-bottom: 1rem;
  border-bottom: 2px solid #2a3f54;
  padding-bottom: 0.5rem;
}

section#fqdn-options h3 {
  font-size: 1.4rem;
  margin-top: 2rem;
  color: #334e68;
}

section#fqdn-options ul {
  list-style: none;
  padding: 0;
  margin-top: 1rem;
}

section#fqdn-options ul li {
  margin-bottom: 1.2rem;
  padding-left: 1.2rem;
  position: relative;
}

section#fqdn-options ul li::before {
  content: "✔";
  position: absolute;
  left: 0;
  color: #2c7a7b;
  font-size: 1rem;
}

section#fqdn-options code {
  font-family: monospace;
  background-color: #f3f4f6;
  color: #1a202c;
  padding: 0.2rem 0.4rem;
  border-radius: 4px;
}

section#fqdn-options pre {
  background-color: #f9fafb;
  border: 1px solid #e2e8f0;
  padding: 1rem;
  overflow-x: auto;
  border-radius: 4px;
  font-size: 0.95rem;
}

section#fqdn-options p {
  line-height: 1.6;
  margin-top: 0.5rem;
  color: #333;
}

    </style>
</head>
<body>
    <header>
        <h1>Form Validator Documentation</h1>
    </header>

    <div class="container">
        <nav>
            <h2>Table of Contents</h2>
            <h3>Validators</h3>
            <ul>
                <li><a href="#TextInputValidator">TextInputValidator</a></li>
                <li><a href="#PasswordInputValidator">PasswordInputValidator</a></li>
                <li><a href="#FormError">FormError</a></li>
                <li><a href="#NumberInputValidator">NumberInputValidator</a></li>
                <li><a href="#TelInputValidator">TelInputValidator</a></li>
                <li><a href="#FQDNInputValidator">FQDNInputValidator</a></li>
                <li><a href="#EmailInputValidator">EmailInputValidator</a></li>
                <li><a href="#URLInputValidator">URLInputValidator</a></li>
                <li><a href="#DateInputValidator">DateInputValidator</a></li>
                <li><a href="#ChoiceInputValidator">ChoiceInputValidator</a></li>
                <li><a href="#ImageValidator">ImageValidator</a></li>
                <li><a href="#DocumentValidator">DocumentValidator</a></li>
                <li><a href="#VideoValidator">VideoValidator</a></li>
                <li><a href="#FieldInputController">FieldInputController</a></li>
                <li><a href="#FormValidateController">FormValidateController</a></li>
                <li><a href="#FQDNOptions">FQDNOptions</a></li>
                <li><a href="#EmailInputOptions">EmailInputOptions</a></li>
                <li><a href="#TextInputOptions">TextInputOptions</a></li>
                <li><a href="#NumberOptions">NumberOptions</a></li>
                <li><a href="#PassworkRuleOptions">PassworkRuleOptions</a></li>
                <li><a href="#TelInputOptions">TelInputOptions</a></li>
                <li><a href="#URLOptions">URLOptions </a></li>
                <li><a href="#DateInputOptions">DateInputOptions</a></li>
                <li><a href="#OptionsFile">OptionsFile</a></li>
                <li><a href="#OptionsImage">OptionsImage</a></li>
                <li><a href="#OptionsMediaVideo">OptionsMediaVideo</a></li>
                <li><a href="#SelectOptions">SelectOptions </a></li>
                <li><a href="#OptionsCheckbox">OptionsCheckbox</a></li>
                <li><a href="#OptionsRadio">OptionsRadio</a></li>
                <li><a href="#OptionsValidateTextarea">OptionsValidateTextarea</a></li>
                <li><a href="#EventClearError">EventClearError</a></li>
                </ul>
        </nav>

        <main>
            <section id="TextInputValidator">
                <h1>Class <code>TextInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>

                <p>
                    The <code>TextInputValidator</code> class is a specialized validator for text-based input fields. It extends <code>FormError</code> for error management and implements <code>TextInputValidatorInterface</code>, ensuring it adheres to a contract for text input validation. This class follows the <strong>singleton pattern</strong>, meaning only one instance of it exists throughout your application, providing a centralized and efficient way to handle text input validation.
                </p>

                ---

                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Ensures a single, globally accessible instance for consistent validation.</li>
                    <li><strong>Required Field Validation:</strong> Checks if an input field is mandatory and has a value.</li>
                    <li><strong>Length Validation:</strong> Validates the minimum and maximum length of the input string.</li>
                    <li><strong>Regular Expression Validation:</strong> Allows custom regex patterns for specific input formats (e.g., email, phone number).</li>
                    <li><strong>HTML/PHP Tag Stripping:</strong> Can escape or strip HTML and PHP tags from input to prevent XSS vulnerabilities.</li>
                    <li><strong>Customizable Error Messages:</strong> Provides flexible options to define user-friendly error messages.</li>
                </ul>

                ---

                <h2>Usage:</h2>
                <p>
                    To use the <code>TextInputValidator</code>, you first obtain its singleton instance. Then, you can call the <code>validate</code> method, passing the input data, the target field name, and an options object to define the validation rules.
                </p>

                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { textInputValidator  } from '@wlindabla/form_validator'

</code></pre>

                <h3>Validating Text Input:</h3>
                <pre><code class="language-typescript">import { TextInputOptions } from '@wlindabla/form_validator'; // Adjust path

const dataToValidate = "Hello World";
const fieldName = "username";
const options = {
    requiredInput: true,
    minLength: 5,
    maxLength: 50,
    regexValidator: /^[a-zA-Z\s]+$/, // Allows letters and spaces
    errorMessageInput: "Username must contain only letters and spaces."
};

textInputValidator.validate(dataToValidate, fieldName, options);

if (!textInputValidator. isFieldValid(fieldName)) {
    const {isValid,errors}=textInputValidator.getState();
    console.log(`Validation errors for ${fieldName}:`,);
} else {
    console.log(`${fieldName} is valid.`);
}
</code></pre>

                <h3>Parameters for <code>validate</code>:</h3>
                <ul>
                    <li><code>datainput</code> (<code>string | undefined</code>): The string value from the input field to be validated.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the input field, used for error reporting.</li>
                    <li><code>optionsinputtext</code> (<code>TextInputOptions</code>): An object containing validation rules. This can include:
                        <ul>
                            <li><code>requiredInput?: boolean</code>: If `true`, the field cannot be empty.</li>
                            <li><code>minLength?: number</code>: The minimum allowed length of the input.</li>
                            <li><code>maxLength?: number</code>: The maximum allowed length of the input.</li>
                            <li><code>regexValidator?: RegExp</code>: A regular expression to test the input against.</li>
                            <li><code>errorMessageInput?: string</code>: A custom error message to display if validation fails.</li>
                            <li><code>escapestripHtmlAndPhpTags?: boolean</code>: If `true`, HTML and PHP tags are escaped/stripped before validation.</li>
                            <li><code>egAwait?: string</code>: An example of the expected format, often appended to error messages.</li>
                        </ul>
                    </li>
                    <li><code>ignoreMergeWithDefaultOptions</code> (<code>boolean</code>, optional): If `true`, default options will not be merged with provided `optionsinputtext`. Defaults to `false`.</li>
                </ul>
                <p>
                    The method returns the current instance of <code>TextInputValidator</code>, allowing for method chaining.
                </p>
            </section>
            <section id="PasswordInputValidator">
                <h1>Class <code>PasswordInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The <code>PasswordInputValidator</code> class is specifically designed to validate password inputs, enforcing a set of configurable rules to ensure password strength and security. It extends <code>FormError</code> for robust error handling and implements <code>PasswordInputValidatorInterface</code>. Following the <strong>singleton pattern</strong>, this class guarantees that only one instance is active across your application, centralizing password validation logic.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Provides a single, consistent entry point for all password validations.</li>
                    <li><strong>Character Type Requirements:</strong> Enforces the inclusion of uppercase letters, lowercase letters, numbers, special characters, and punctuation.</li>
                    <li><strong>Length Constraints:</strong> Validates minimum and maximum password length.</li>
                    <li><strong>Custom Regular Expressions:</strong> Allows for highly flexible validation rules using custom regex for each character type.</li>
                    <li><strong>Password Strength Scoring:</strong> Integrates with <code>analyzeWord</code> and <code>scoreWord</code> utilities to provide a numerical score and complexity level (weak, medium, strong) for the password. Dispatches a custom event with scoring details.</li>
                    <li><strong>Inherited Error Management:</strong> Utilizes the error reporting capabilities from <code>FormError</code> for clear and consistent feedback.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate a password, retrieve the singleton instance of <code>PasswordInputValidator</code>. Then, call the <code>validate</code> method with the password string, its input name, and an options object defining the validation rules. You can also provide options for password strength analysis and scoring.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { passwordInputValidator } from '@wlindabla/form_validator';
            
       
            </code></pre>
            
                <h3>Validating a Password:</h3>
                <pre><code class="language-typescript">import { PassworkRuleOptions } from '@wlindabla/form_validator'; // Adjust path
            import { AnalyzeWordOptions, WordScoringOptions } from '@wlindabla/form_validator'; // Adjust path
            
            const password = "SecurePassword123!";
            const fieldName = "userPassword";
            
            const validationOptions: PassworkRuleOptions = {
                minLength: 12,
                maxLength: 64,
                upperCaseAllow: true,
                lowerCaseAllow: true,
                numberAllow: true,
                symbolAllow: true, // Renamed from specialChar in the example code snippet
                // punctuationAllow: true, // You can also enable punctuation checking
                enableScoring: true // Enable password strength scoring
            };
            
            // Optional: Custom options for password analysis and scoring
            const analysisOptions: AnalyzeWordOptions = {
                // ... custom regex or allowed character types
            };
            
            const scoringOptions: WordScoringOptions = {
                pointsPerLength: 3,
                bonusForContainingUpper: 15,
                bonusForContainingNumber: 15,
                bonusForContainingSymbol: 20
            };
            
            passwordInputValidator.validate(
                password,
                fieldName,
                validationOptions,
                false, // Merge with default options
                analysisOptions,
                scoringOptions
            );
            
            if (!passwordInputValidator. isFieldValid(fieldName)) {
                console.log(`Password validation failed for ${fieldName}:`, passwordInputValidator.getFieldErrors());
            } else {
                console.log(`${fieldName} password is valid.`);
            }
            
            // Listen for the custom event dispatched after scoring (if enabled)
            document.addEventListener('SCORE_ANALYSIS_PASSWORD', (event: CustomEvent) => {
                const { score, analysis, input } = event.detail;
                console.log(`Password score for ${input}:`, score);
                console.log('Analysis details:', analysis);
            });
            </code></pre>
            
                <h3>Parameters for <code>validate</code>:</h3>
                <ul>
                    <li><code>datainput</code> (<code>string</code>): The password string to be validated.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the input field, used for error reporting.</li>
                    <li><code>optionsinputtext</code> (<code>PassworkRuleOptions</code>): An object defining the specific password rules. This includes:
                        <ul>
                            <li><code>minLength?: number</code>: Minimum allowed password length.</li>
                            <li><code>maxLength?: number</code>: Maximum allowed password length.</li>
                            <li><code>upperCaseAllow?: boolean</code>: If <code>true</code>, requires at least one uppercase letter.</li>
                            <li><code>lowerCaseAllow?: boolean</code>: If <code>true</code>, requires at least one lowercase letter.</li>
                            <li><code>numberAllow?: boolean</code>: If <code>true</code>, requires at least one digit.</li>
                            <li><code>symbolAllow?: boolean</code>: If <code>true</code>, requires at least one special character (non-alphanumeric, non-punctuation).</li>
                            <li><code>punctuationAllow?: boolean</code>: If <code>true</code>, requires at least one punctuation character.</li>
                            <li><code>customUpperRegex?: RegExp</code>, <code>customLowerRegex?: RegExp</code>, etc.: Custom regex for specific character types.</li>
                            <li><code>regexValidator?: RegExp</code>: An overall regex for the password.</li>
                            <li><code>requiredInput?: boolean</code>: If <code>true</code>, the field cannot be empty.</li>
                            <li><code>enableScoring?: boolean</code>: If <code>true</code>, enables password strength analysis and scoring.</li>
                        </ul>
                    </li>
                    <li><code>ignoreMergeWithDefaultOptions</code> (<code>boolean</code>, optional): If <code>true</code>, default options will not be merged with provided `optionsinputtext`. Defaults to `false`.</li>
                    <li><code>ananalyzePasswordOptions</code> (<code>AnalyzeWordOptions</code>, optional): Custom options for the <code>analyzeWord</code> utility when scoring.</li>
                    <li><code>scoringPasswordOptions</code> (<code>WordScoringOptions</code>, optional): Custom options for the <code>scoreWord</code> utility when scoring.</li>
                </ul>
                <p>
                    The method returns the current instance of <code>PasswordInputValidator</code>, allowing for method chaining.
                </p>
            </section>
            <section id="FormError">
                <h1>Abstract Class <code>FieldValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `FormError` abstract class serves as the **base class for all validators** in this library. It provides a foundational structure for managing validation states and error messages across form fields. By inheriting from `FormError`, all specific validators (like `TextInputValidator`, `PasswordInputValidator`, `ImageValidator`, etc.) gain a consistent mechanism for handling and reporting validation errors.
                </p>
                <p>
                    It interacts with an internal `formErrorStore` to keep track of the validation status and associated error messages for each input field. This ensures a centralized and standardized approach to error handling throughout your application.
                </p>
            
                ---
            
                <h2>Key Methods:</h2>
            
                <h3><code>areAllFieldsValid(): boolean</code></h3>
                <ul>
                    <li><strong>Description:</strong> Checks if all form fields currently tracked by the error state manager are valid. This is useful for determining if a form can be submitted or if further action is required.</li>
                    <li><strong>Returns:</strong> `true` if all fields are valid (i.e., no errors have been set for any field), otherwise `false`.</li>
                </ul>
            
                <h3><code>removeSpecificErrorMessage(targetInputname: string, messageerrorinput: string): this</code></h3>
                <ul>
                    <li><strong>Description:</strong> Removes a specific error message associated with a given input field. This is useful when an error condition is resolved for a particular field without clearing all errors for that field.</li>
                    <li><strong>Parameters:</strong>
                        <ul>
                            <li>`targetInputname` (`string`): The name of the input field.</li>
                            <li>`messageerrorinput` (`string`): The specific error message to remove.</li>
                        </ul>
                    </li>
                    <li><strong>Returns:</strong> The current instance of the validator, allowing method chaining.</li>
                </ul>
            
                <h3><code> isFieldValid(targetInputname: string): boolean</code></h3>
                <ul>
                    <li><strong>Description:</strong> Checks if a specific input field has any validation errors.</li>
                    <li><strong>Parameters:</strong>
                        <ul>
                            <li>`targetInputname` (`string`): The name of the input field to check.</li>
                        </ul>
                    </li>
                    <li><strong>Returns:</strong> `true` if the specified field has errors, otherwise `false`.</li>
                </ul>
            
                <h3><code>clearError(targetInputname: string): this</code></h3>
                <ul>
                    <li><strong>Description:</strong> Clears all error messages and resets the validation status for a specific input field. This is typically used when a user starts re-entering data into a field after an error has been displayed.</li>
                    <li><strong>Parameters:</strong>
                        <ul>
                            <li>`targetInputname` (`string`): The name of the input field whose errors should be cleared.</li>
                        </ul>
                    </li>
                    <li><strong>Returns:</strong> The current instance of the validator, allowing method chaining.</li>
                </ul>
            
                <h3><code>setValidatorState(status: boolean, error_message: string, targetInputname: string): this</code></h3>
                <ul>
                    <li><strong>Description:</strong> Sets the validation status and an associated error message for a given input field. This is the core method used by specific validators to report validation failures.</li>
                    <li><strong>Parameters:</strong>
                        <ul>
                            <li>`status` (`boolean`): The validation status (`true` for valid, `false` for invalid).</li>
                            <li>`error_message` (`string`): The error message to associate with the field if `status` is `false`.</li>
                            <li>`targetInputname` (`string`): The name of the input field.</li>
                        </ul>
                    </li>
                    <li><strong>Returns:</strong> The current instance of the validator, allowing method chaining.</li>
                </ul>
            
                <h3><code>getSate(targetInputname: string): FieldStateValidating</code></h3>
                <ul>
                    <li><strong>Description:</strong> Retrieves the current validation status and any associated error message for a specific input field.</li>
                    <li><strong>Parameters:</strong>
                        <ul>
                            <li>`targetInputname` (`string`): The name of the input field.</li>
                        </ul>
                    </li>
                    <li><strong>Returns:</strong> An object `{isValid: boolean; errors: string[]|[]; }` containing the validation status and an array of error messages for the field.</li>
                </ul>
            
                ---
            
                <h2>Usage Example:</h2>
                <p>
                    While `FieldValidator` is an abstract class and cannot be instantiated directly, its methods are available to all classes that extend it. Here's a conceptual example of how a derived validator might use these methods:
                </p>
                <pre><code class="language-typescript">// Inside a derived validator, e.g., EmailValidator
            class EmailValidator extends FieldValidator {
                validate(email: string, fieldName: string): this {
                    this.clearError(fieldName); // Always good practice to clear previous errors
            
                    if (!email) {
                        this.setValidatorStatus(false, "Email is required.", fieldName);
                        return this;
                    }
            
                    // Basic email regex for demonstration
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (!emailRegex.test(email)) {
                        this.setValidatorStatus(false, "Invalid email format.", fieldName);
                    } else {
                        // If validation passes, ensure status is true and no error messages
                        // (though setValidatorStatus with true status implicitly handles this)
                        this.setValidatorStatus(true, "", fieldName);
                    }
                    return this;
                }
            }
            
            const emailVal = new EmailValidator().getInstance() // Assuming concrete implementation
            emailVal.validateEmail("test@example.com", "userEmail");
            console.log("Has errors for userEmail?", emailVal. isFieldValid("userEmail"));
            console.log("Validator status for userEmail:", emailVal.getValidatorStatus("userEmail"));
            
            emailVal.validateEmail("invalid-email", "userEmail");
            console.log("Has errors for userEmail (after invalid)?", emailVal. isFieldValid("userEmail"));
            console.log("Validator status for userEmail (after invalid):", emailVal.getValidatorStatus("userEmail"));
            
            console.log("Are all fields valid?", emailVal.areAllFieldsValid());
            </code></pre>
            </section>
            <section id="NumberInputValidator">
                <h1>Class <code>NumberInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `NumberInputValidator` class is designed for validating numerical inputs. It ensures that values are indeed numbers and fall within specified ranges, respect a given step, and can even match a custom regular expression. This class extends `FormError` for consistent error management and implements `NumberInputValidatorInterface`. Like other validators in this library, it follows the **singleton pattern**, providing a single, globally accessible instance for efficient number validation.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Ensures a unique instance for centralized number validation.</li>
                    <li><strong>Numeric Type Checking:</strong> Verifies if the input can be converted to a valid number.</li>
                    <li><strong>Range Validation:</strong> Checks if the number is within a specified minimum (`min`) and maximum (`max`) value.</li>
                    <li><strong>Step Validation:</strong> Ensures the number is a valid multiple of a given `step` value.</li>
                    <li><strong>Custom Regular Expression:</strong> Allows applying a custom regex for specific number formats (e.g., currency, phone numbers).</li>
                    <li><strong>Inherited Error Management:</strong> Leverages the error handling capabilities of `FormError` for clear reporting.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate a number input, first get the singleton instance of `NumberInputValidator`. Then, call the `validate` method, providing the input value, its field name, and an optional `NumberOptions` object to define specific validation rules.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { numberInputValidator as numberValidator } from '@wlindabla/form_validator';
            
            
            </code></pre>
            
                <h3>Validating a Number Input:</h3>
                <pre><code class="language-typescript">import { NumberOptions } from '@wlindabla/form_validator'; // Adjust path
            
            // Example 1: Basic number validation
            let value1 = "123";
            let fieldName1 = "quantity";
            numberValidator.validate(value1, fieldName1);
            
            if (numberValidator. isFieldValid(fieldName1)) {
                console.log(`Validation errors for ${fieldName1}:`, numberValidator.getFieldErrors());
            } else {
                console.log(`${fieldName1} is valid.`); // Output: quantity is valid.
            }
            
            // Example 2: Number within a range
            let value2 = "75";
            let fieldName2 = "age";
            const options2: NumberOptions = { min: 18, max: 120 };
            numberValidator.numberValidator(value2, fieldName2, options2);
            
            if (numberValidator. isFieldValid(fieldName2)) {
                console.log(`Validation errors for ${fieldName2}:`, numberValidator.getFieldErrors());
            } else {
                console.log(`${fieldName2} is valid.`); // Output: age is valid.
            }
            
            // Example 3: Number with step validation (invalid)
            let value3 = "10.5";
            let fieldName3 = "price";
            const options3: NumberOptions = { min: 0, step: 1 };
            numberValidator.validate(value3, fieldName3, options3);
            
            if (numberValidator.isFieldValid(fieldName3)) {
                console.log(`Validation errors for ${fieldName3}:`, numberValidator.getFieldErrors());
                // Output: Validation errors for price: { price: "The value 10.5 must be a multiple of 1." }
            } else {
                console.log(`${fieldName3} is valid.`);
            }
            
            // Example 4: Invalid number input
            let value4 = "abc";
            let fieldName4 = "id";
            numberValidator.validate(value4, fieldName4);
            
            if (numberValidator.isFieldValid(fieldName4)) {
                console.log(`Validation errors for ${fieldName4}:`, numberValidator.getFieldErrors());
                // Output: Validation errors for id: { id: "Please enter a valid number." }
            }
            </code></pre>
            
                <h3>Parameters for <code>numberValidator</code>:</h3>
                <ul>
                    <li><code>val</code> (<code>string | number</code>): The input value to be validated. It can be a string (which will be parsed to a float) or a number.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the input field, used for error reporting.</li>
                    <li><code>options_number</code> (<code>NumberOptions</code>, optional): An object containing the validation rules for the number. This can include:
                        <ul>
                            <li><code>min?: number</code>: The minimum allowed numeric value.</li>
                            <li><code>max?: number</code>: The maximum allowed numeric value.</li>
                            <li><code>step?: number</code>: The allowed increment/decrement step for the number.</li>
                            <li><code>regexValidator?: RegExp</code>: An optional regular expression to validate the string representation of the number.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    The method returns the current instance of `NumberInputValidator`, allowing for method chaining.
                </p>
            </section>
            <section id="DateInputValidator">
                <h1>Class <code>DateInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `DateInputValidator` class is designed to validate date inputs, ensuring they adhere to specified formats, ranges, and temporal constraints (future/past dates). It extends `FormError` for consistent error management and implements `DateInputValidatorInterface`. This validator also follows the **singleton pattern**, providing a single, globally accessible instance for efficient date validation.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Ensures a unique instance for centralized date validation.</li>
                    <li><strong>Format Validation:</strong> Validates the input date string against a specified format (e.g., 'YYYY/MM/DD', 'DD-MM-YYYY').</li>
                    <li><strong>Strict Mode:</strong> Enforces exact length matching with the format for stricter validation.</li>
                    <li><strong>Delimiter Detection:</strong> Automatically detects common date delimiters (e.g., '/', '-').</li>
                    <li><strong>Date Range Validation:</strong> Checks if the date falls within a specified minimum (`minDate`) and maximum (`maxDate`).</li>
                    <li><strong>Future/Past Date Restrictions:</strong> Allows or disallows dates in the future or past relative to the current date.</li>
                    <li><strong>Two-Digit Year Handling:</strong> Intelligently interprets two-digit years (e.g., '99' as 1999, '25' as 2025).</li>
                    <li><strong>Inherited Error Management:</strong> Leverages the error handling capabilities of `FormError` for clear reporting.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate a date input, first get the singleton instance of `DateInputValidator`. Then, call the `dateValidator` method, providing the date input (string or Date object), its field name, and an optional `DateInputOptions` object to define specific validation rules.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { dateInputValidator as dateValidator} from './path/to/DateInputValidator';
            
           
            </code></pre>
            
                <h3>Validating a Date Input:</h3>
                <pre><code class="language-typescript">import { dateInputOptions as dateValidator } from './path/to/YourOptionsInterface'; // Adjust path
            
            // Example 1: Basic date validation with default format
            let date1 = "2023/10/26";
            let fieldName1 = "eventDate";
            dateValidator.validate(date1, fieldName1);
            
            if (dateValidator.isFieldValid(fieldName1)) {
                console.log(`Validation errors for ${fieldName1}:`, dateValidator.getFieldErrors());
            } else {
                console.log(`${fieldName1} is valid.`); // Output: eventDate is valid.
            }
            
            // Example 2: Date with a custom format and strict mode
            let date2 = "01-15-2024";
            let fieldName2 = "birthDate";
            const options2: DateInputOptions = {
                format: 'MM-DD-YYYY',
                strictMode: true,
                delimiters: ['-'],
                maxDate: new Date('2024-01-01') // Birth date should be before 2024
            };
            dateValidator.validate(date2, fieldName2, options2);
            
            if (dateValidator.isFieldValid(fieldName2)) {
                console.log(`Validation errors for ${fieldName2}:`, dateValidator.getFieldErrors());
                // Output: Validation errors for birthDate: { birthDate: "The date must be before Tue Jan 01 2024..." }
            } else {
                console.log(`${fieldName2} is valid.`);
            }
            
            // Example 3: Disallowing future dates
            let futureDate = new Date(new Date().getFullYear() + 1, 0, 1).toISOString().split('T')[0]; // Jan 1st next year
            let fieldName3 = "registrationDate";
            const options3: DateInputOptions = { allowFuture: false };
            dateValidator.validate(futureDate, fieldName3, options3);
            
            if (dateValidator.isFieldValid(fieldName3)) {
                console.log(`Validation errors for ${fieldName3}:`, dateValidator.getFieldErrors());
                // Output: Validation errors for registrationDate: { registrationDate: "The date "YYYY-MM-DD" cannot be in the future." }
            } else {
                console.log(`${fieldName3} is valid.`);
            }
            
            // Example 4: Invalid date string
            let date4 = "2023/13/01"; // Invalid month
            let fieldName4 = "invalidDate";
            dateValidator.dateValidator(date4, fieldName4);
            
            if (dateValidator.isFieldValid(fieldName4)) {
                console.log(`Validation errors for ${fieldName4}:`, dateValidator.  getFieldErrors());
                // Output: Validation errors for invalidDate: { invalidDate: "Invalid date created from input." }
            }
            </code></pre>
            
                <h3>Parameters for <code>dateValidator</code>:</h3>
                <ul>
                    <li><code>date_input</code> (<code>string | Date</code>): The date value to be validated. It can be a string (which will be parsed according to the format) or a JavaScript `Date` object.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the input field, used for error reporting.</li>
                    <li><code>date_options</code> (<code>DateInputOptions</code>, optional): An object containing the validation rules for the date. This can include:
                        <ul>
                            <li><code>format?: string</code>: The expected format of the date string (e.g., 'YYYY/MM/DD', 'DD-MM-YYYY'). Defaults to 'YYYY/MM/DD'.</li>
                            <li><code>strictMode?: boolean</code>: If `true`, the input date string must exactly match the length of the `format` string.</li>
                            <li><code>delimiters?: string[]</code>: An array of possible delimiters used in the date string. Defaults to `['/', '-']`.</li>
                            <li><code>minDate?: Date</code>: The earliest allowed date.</li>
                            <li><code>maxDate?: Date</code>: The latest allowed date.</li>
                            <li><code>allowFuture?: boolean</code>: If `false`, dates in the future are not allowed.</li>
                            <li><code>allowPast?: boolean</code>: If `false`, dates in the past are not allowed.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    The method returns the current instance of `DateInputValidator`, allowing for method chaining.
                </p>
            </section>
            <section id="TelInputValidator">
                <h1>Class <code>TelInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `TelInputValidator` class is designed to validate telephone numbers, ensuring they adhere to international formatting standards and optional length constraints. It leverages the `libphonenumber-js` library for robust parsing and validation. This class extends `FormError` for consistent error management and implements `TelInputValidatorInterface`. Following the **singleton pattern**, it provides a single, globally accessible instance for efficient phone number validation.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Ensures a unique instance for centralized phone number validation.</li>
                    <li><strong>International Format Enforcement:</strong> Requires phone numbers to start with a '+' for international dialing codes.</li>
                    <li><strong>`libphonenumber-js` Integration:</strong> Utilizes a powerful external library for accurate phone number parsing, validation, and formatting.</li>
                    <li><strong>Default Country Configuration:</strong> Allows specifying a default country for numbers that might not include an explicit country code.</li>
                    <li><strong>Automatic Formatting (with jQuery):</strong> If jQuery is present, it can automatically format the input field to an international standard format.</li>
                    <li><strong>Length and Required Input Validation:</strong> Integrates with `TextInputValidator` for basic length checks and required field validation.</li>
                    <li><strong>Comprehensive Error Handling:</strong> Provides specific error messages for invalid formats, parsing issues, and general validation failures.</li>
                    <li><strong>Inherited Error Management:</strong> Leverages the error handling capabilities of `FormError` for clear reporting.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate a telephone number, first get the singleton instance of `TelInputValidator`. Then, call the `telValidator` method, providing the phone number string, its field name, and a `TelInputOptions` object to define specific validation rules and default behaviors.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { telInputValidator as telValidator} from '@wlindabla/form_validator';
            
           
            </code></pre>
            
                <h3>Validating a Telephone Number:</h3>
                <pre><code class="language-typescript">import { TelInputOptions } from '@wlindabla/form_validator'; // Adjust path
            
            // Example 1: Validating an international phone number with a default country
            let phoneNumber1 = "+12125550100"; // US number
            let fieldName1 = "userPhone";
            const options1: TelInputOptions = {
                defaultCountry: 'US',
                egAwait: '+1 (212) 555-0100' // Example for error messages
            };
            telValidator.validate(phoneNumber1, fieldName1, options1);
            
            if (telValidator. isFieldValid(fieldName1)) {
                console.log(`Validation errors for ${fieldName1}:`, telValidator.getFieldErrors());
            } else {
                console.log(`${fieldName1} is valid.`); // Output: userPhone is valid.
                // If jQuery is loaded, the input field named "userPhone" might be updated to "+1 212-555-0100"
            }
            
            // Example 2: Invalid phone number (missing '+')
            let phoneNumber2 = "22997000000";
            let fieldName2 = "contactPhone";
            const options2: TelInputOptions = {
                defaultCountry: 'BJ', // Benin
                errorMessageInput: "Please provide a valid Benin phone number."
            };
            telValidator.telValidator(phoneNumber2, fieldName2, options2);
            
            if (telValidator. isFieldValid(fieldName2)) {
                console.log(`Validation errors for ${fieldName2}:`, telValidator.getFieldErrors());
                // Output: Validation errors for contactPhone: { contactPhone: "Please enter a valid international number starting with '+' or select a country code." }
            }
            
            // Example 3: Invalid phone number format or non-existent number for the country
            let phoneNumber3 = "+229123"; // Too short for Benin
            let fieldName3 = "mobile";
            const options3: TelInputOptions = {
                defaultCountry: 'BJ',
                egAwait: '+229 01 67 25 18 86'
            };
            telValidator.telValidator(phoneNumber3, fieldName3, options3);
            
            if (telValidator.isFieldValid(fieldName3)) {
                console.log(`Validation errors for ${fieldName3}:`, telValidator.getFieldErrors());
                // Output: Validation errors for mobile: { mobile: "Invalid phone number. e.g. +229 01 67 25 18 86" }
            }
            </code></pre>
            
                <h3>Parameters for <code>validate</code>:</h3>
                <ul>
                    <li><code>data_tel</code> (<code>string</code>): The telephone number string to be validated.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the input field, used for error reporting.</li>
                    <li><code>optionsinputTel</code> (<code>TelInputOptions</code>): An object containing the validation rules and configuration for the phone number. This includes:
                        <ul>
                            <li><code>defaultCountry?: string</code>: An optional ISO 2-letter country code (e.g., 'US', 'BJ') to use as the default if the number does not include an explicit country code. This is crucial for `libphonenumber-js` to correctly parse local numbers.</li>
                            <li><code>egAwait?: string</code>: An example of an expected valid phone number format, displayed in error messages.</li>
                            <li><code>errorMessageInput?: string</code>: A custom error message to use if general phone number validation fails.</li>
                            <li><code>minLength?: number</code>: The minimum allowed length of the phone number string.</li>
                            <li><code>maxLength?: number</code>: The maximum allowed length of the phone number string.</li>
                            <li><code>requiredInput?: boolean</code>: If `true`, the field cannot be empty.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    The method returns the current instance of `TelInputValidator`, allowing for method chaining.
                </p>
            </section>
            <section id="FQDNInputValidator">
                <h1>Class <code>FQDNInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `FQDNInputValidator` class is dedicated to validating Fully Qualified Domain Names (FQDNs), ensuring they conform to standard DNS naming conventions and additional configurable rules. This class extends `FormError` for consistent error management and implements `FQDNInputValidatorInterface`. Like other validators in this library, it follows the **singleton pattern**, providing a single, globally accessible instance for efficient FQDN validation.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Ensures a unique instance for centralized FQDN validation.</li>
                    <li><strong>TLD (Top-Level Domain) Requirements:</strong> Can enforce the presence and validity of a TLD, including support for internationalized TLDs.</li>
                    <li><strong>Character Restrictions:</strong> Checks for invalid characters, full-width characters, and labels starting or ending with hyphens.</li>
                    <li><strong>Length Constraints:</strong> Validates that each domain label does not exceed 63 characters.</li>
                    <li><strong>Configurable Rules:</strong> Allows enabling or disabling specific rules such as:
                        <ul>
                            <li>`requireTLD`: Whether a TLD is mandatory.</li>
                            <li>`allowedUnderscores`: Whether underscores are permitted (not typically valid in DNS).</li>
                            <li>`allowTrailingDot`: Whether a trailing dot is allowed.</li>
                            <li>`allowNumericTld`: Whether purely numeric TLDs are permitted.</li>
                            <li>`allowWildcard`: Whether wildcard domains (e.g., `*.example.com`) are allowed.</li>
                            <li>`ignoreMaxLength`: Whether to bypass the 63-character label length check.</li>
                        </ul>
                    </li>
                    <li><strong>HTML Escaping:</strong> Automatically escapes HTML tags to prevent potential XSS issues.</li>
                    <li><strong>Inherited Error Management:</strong> Leverages the error handling capabilities of `FormError` for clear reporting.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate an FQDN, first get the singleton instance of `FQDNInputValidator`. Then, call the `fqdnValidator` method, providing the FQDN string, its field name, and an `FQDNOptions` object to define specific validation rules.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { fqdnInputValidator as fqdnValidator} from '@wlindabla/form_validator';
            
            </code></pre>
            
                <h3>Validating an FQDN:</h3>
                <pre><code class="language-typescript">import { FQDNOptions } from '@wlindabla/form_validator'; // Adjust path
            
            // Example 1: Basic valid FQDN
            let domain1 = "www.example.com";
            let fieldName1 = "website";
            const options1: FQDNOptions = {}; // Use default options
            await fqdnValidator.validate(domain1, fieldName1, options1);
            
            if (fqdnValidator.isFieldValid(fieldName1)) {
                console.log(`Validation errors for ${fieldName1}:`, fqdnValidator.getFieldErrors());
            } else {
                console.log(`${fieldName1} is valid.`); // Output: website is valid.
            }
            
            // Example 2: FQDN with an invalid TLD (numeric TLD not allowed by default)
            let domain2 = "example.123";
            let fieldName2 = "testDomain";
            const options2: FQDNOptions = { allowNumericTld: false }; // Explicitly disallow numeric TLDs
            await fqdnValidator.fqdnValidator(domain2, fieldName2, options2);
            
            if (fqdnValidator.isFieldValid(fieldName2)) {
                console.log(`Validation errors for ${fieldName2}:`, fqdnValidator.getFieldErrors());
                // Output: Validation errors for testDomain: { testDomain: "example.123 must not use a numeric TLD." }
            }
            
            // Example 3: FQDN with underscore (not allowed by default)
            let domain3 = "my_site.example.com";
            let fieldName3 = "subdomain";
            const options3: FQDNOptions = { allowedUnderscores: false };
            await fqdnValidator.fqdnValidator(domain3, fieldName3, options3);
            
            if (fqdnValidator.isFieldValid(fieldName3)) {
                console.log(`Validation errors for ${fieldName3}:`, fqdnValidator.getFieldErrors());
                // Output: Validation errors for subdomain: { subdomain: "my_site.example.com must not contain underscores." }
            }
            
            // Example 4: FQDN with wildcard allowed
            let domain4 = "*.dev.example.com";
            let fieldName4 = "wildcardDomain";
            const options4: FQDNOptions = { allowWildcard: true };
            await fqdnValidator.fqdnValidator(domain4, fieldName4, options4);
            
            if (fqdnValidator.isFieldValid(fieldName4)) {
                console.log(`Validation errors for ${fieldName4}:`, fqdnValidator.getFieldErrors());
            } else {
                console.log(`${fieldName4} is valid.`); // Output: wildcardDomain is valid.
            }
            </code></pre>
            
                <h3>Parameters for <code>validate</code>:</h3>
                <ul>
                    <li><code>input</code> (<code>string</code>): The FQDN string to be validated.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the input field, used for error reporting.</li>
                    <li><code>fqdnOptions</code> (<code>FQDNOptions</code>): An object containing the validation rules for the FQDN. This includes:
                        <ul>
                            <li><code>requireTLD?: boolean</code>: If `true`, the FQDN must include a top-level domain (e.g., '.com', '.org'). Defaults to `true`.</li>
                            <li><code>allowedUnderscores?: boolean</code>: If `true`, underscores are allowed in domain labels. Defaults to `false`.</li>
                            <li><code>allowTrailingDot?: boolean</code>: If `true`, a trailing dot at the end of the FQDN is permitted. Defaults to `false`.</li>
                            <li><code>allowNumericTld?: boolean</code>: If `true`, purely numeric TLDs (e.g., 'example.123') are allowed. Defaults to `false`.</li>
                            <li><code>allowWildcard?: boolean</code>: If `true`, a leading wildcard character ('*.') is allowed. Defaults to `false`.</li>
                            <li><code>ignoreMaxLength?: boolean</code>: If `true`, bypasses the check for individual domain label lengths (max 63 characters). Defaults to `false`.</li>
                        </ul>
                    </li>
                    <li><code>ignoreMergeWithDefaultOptions</code> (<code>boolean</code>, optional): If `true`, default options will not be merged with provided `fqdnOptions`. Defaults to `false`.</li>
                </ul>
                <p>
                    The method returns a Promise that resolves to the current instance of `FQDNInputValidator`, allowing for asynchronous operations and method chaining.
                </p>
            </section>
            <section id="EmailInputValidator">
                <h1>Class <code>EmailInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `EmailInputValidator` class is a robust tool for validating email addresses, adhering to various standards (RFC 5322, RFC 6531 for UTF-8) and offering extensive customization. It extends `FormError` for integrated error handling and implements `EmailInputValidatorInterface`. This class follows the **singleton pattern** to ensure a single, efficient instance for all email validation needs across your application.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Provides a unique instance for centralized email validation.</li>
                    <li><strong>Comprehensive Validation:</strong> Checks email format, local part, domain part, and overall length.</li>
                    <li><strong>Display Name Support:</strong> Can validate and optionally require display names (e.g., "John Doe" &lt;john@example.com&gt;).</li>
                    <li><strong>Domain Validation:</strong>
                        <ul>
                            <li>Integrates with `FQDNInputValidator` for strict Fully Qualified Domain Name validation.</li>
                            <li>Supports IP address domains (e.g., `user@[192.168.1.1]`) with an optional flag.</li>
                            <li>Allows host blacklisting and whitelisting for domain control.</li>
                        </ul>
                    </li>
                    <li><strong>Local Part Validation:</strong>
                        <ul>
                            <li>Supports standard local parts (e.g., `user.name`).</li>
                            <li>Handles quoted local parts (e.g., `"user.name"`).</li>
                            <li>Allows UTF-8 characters in the local part for international email addresses.</li>
                            <li>Can blacklist specific characters in the local part.</li>
                        </ul>
                    </li>
                    <li><strong>Length Constraints:</strong> Validates overall email length, as well as separate lengths for local and domain parts (up to 64 and 254 characters respectively).</li>
                    <li><strong>HTML Escaping:</strong> Automatically escapes HTML tags in the input to prevent XSS vulnerabilities.</li>
                    <li><strong>Inherited Error Management:</strong> Leverages the robust error handling of `FormError` for clear and precise feedback.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate an email address, get the singleton instance of `EmailInputValidator`. Then, call the `emailValidator` method, providing the email string, its field name, and an `EmailInputOptions` object to define specific validation rules.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { emailInputValidator as emailValidator} from '@wlindabla/form_validator';
            
            </code></pre>
            
                <h3>Validating an Email Address:</h3>
                <pre><code class="language-typescript">import { EmailInputOptions } from '@wlindabla/form_validator'; // Adjust path
            
            // Example 1: Basic valid email
            let email1 = "test@example.com";
            let fieldName1 = "userEmail";
            const options1: EmailInputOptions = {}; // Use default options
            await emailValidator.validate(email1, fieldName1, options1);
            
            if (emailValidator.isFieldValid(fieldName1)) {
                console.log(`Validation errors for ${fieldName1}:`, emailValidator.getFieldErrors());
            } else {
                console.log(`${fieldName1} is valid.`); // Output: userEmail is valid.
            }
            
            // Example 2: Email with display name required (but not provided)
            let email2 = "no-display-name@example.com";
            let fieldName2 = "contactEmail";
            const options2: EmailInputOptions = { requireDisplayName: true };
            await emailValidator.validate(email2, fieldName2, options2);
            
            if (emailValidator.isFieldValid(fieldName2)) {
                console.log(`Validation errors for ${fieldName2}:`, emailValidator.getFieldErrors());
                // Output: { contactEmail: "contactEmail field must include a display name like "John Doe <example@email.com>"" }
            }
            
            // Example 3: Email with display name provided and valid
            let email3 = "John Doe <john.doe@example.com>";
            let fieldName3 = "userAccountEmail";
            const options3: EmailInputOptions = { allowDisplayName: true };
            await emailValidator.validate(email3, fieldName3, options3);
            
            if (emailValidator.isFieldValid(fieldName3)) {
                console.log(`Validation errors for ${fieldName3}:`, emailValidator.getFieldErrors());
            } else {
                console.log(`${fieldName3} is valid.`); // Output: userAccountEmail is valid.
            }
            
            // Example 4: Email with a blacklisted host
            let email4 = "user@tempmail.com";
            let fieldName4 = "registrationEmail";
            const options4: EmailInputOptions = { hostBlacklist: ['tempmail.com', 'mailinator.com'] };
            await emailValidator.emailValidator(email4, fieldName4, options4);
            
            if (emailValidator.isFieldValid(fieldName4)) {
                console.log(`Validation errors for ${fieldName4}:`, emailValidator.getFieldErrors());
                // Output: { registrationEmail: "registrationEmail field contains a blacklisted domain: "tempmail.com"." }
            }
            
            // Example 5: Email with an IP domain (allowed)
            let email5 = "admin@[192.168.1.1]";
            let fieldName5 = "serverEmail";
            const options5: EmailInputOptions = { allowIpDomain: true };
            await emailValidator.emailValidator(email5, fieldName5, options5);
            
            if (emailValidator.isFieldValid(fieldName5)) {
                console.log(`Validation errors for ${fieldName5}:`, emailValidator.getFieldErrors());
            } else {
                console.log(`${fieldName5} is valid.`); // Output: serverEmail is valid.
            }
            </code></pre>
            
                <h3>Parameters for <code>validate</code>:</h3>
                <ul>
                    <li><code>datainput</code> (<code>string</code>): The email address string to be validated.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the input field, used for error reporting.</li>
                    <li><code>optionsinputemail</code> (<code>EmailInputOptions</code>): An object containing the validation rules and configuration for the email address. This includes:
                        <ul>
                            <li><code>allowUtf8LocalPart?: boolean</code>: If `true`, allows UTF-8 characters in the local part of the email address. Defaults to `true`.</li>
                            <li><code>allowIpDomain?: boolean</code>: If `true`, allows IP addresses as the domain part (e.g., `user@[192.168.1.1]`). Defaults to `true`.</li>
                            <li><code>allowQuotedLocal?: boolean</code>: If `true`, allows the local part to be enclosed in double quotes (e.g., `"first.last"@example.com`). Defaults to `true`.</li>
                            <li><code>ignoreMaxLength?: boolean</code>: If `true`, bypasses the default max length checks for the entire email (254 chars), local part (64 chars), and domain part (254 chars). Defaults to `false`.</li>
                            <li><code>hostBlacklist?: string[]</code>: An array of domain names that are not allowed.</li>
                            <li><code>hostWhitelist?: string[]</code>: An array of domain names that are exclusively allowed. If provided, any domain not in this list will be rejected.</li>
                            <li><code>blacklistedChars?: string</code>: A string of characters that are forbidden in the local part of the email.</li>
                            <li><code>requireDisplayName?: boolean</code>: If `true`, the email must include a display name (e.g., "John Doe" &lt;john@example.com&gt;). Defaults to `false`.</li>
                            <li><code>allowDisplayName?: boolean</code>: If `true`, allows an optional display name. Defaults to `false`.</li>
                            <li>Any other options inherited from `FQDNInputValidator` (e.g., `requireTLD`, `allowedUnderscores`).</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    The method returns a Promise that resolves to the current instance of `EmailInputValidator`, allowing for asynchronous operations and method chaining.
                </p>
            </section>
            <section id="URLInputValidator">
                <h1>Class <code>URLInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `URLInputValidator` class is designed for comprehensive validation of URLs, ensuring they conform to standard formatting, protocol requirements, host restrictions, and various other configurable criteria. It extends `FormError` for integrated error handling and implements `URLInputValidatorInterface`. Following the **singleton pattern**, this class provides a single, globally accessible instance for efficient and consistent URL validation across your application.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Ensures a unique instance for centralized URL validation.</li>
                    <li><strong>Basic Format Check:</strong> Quickly rejects inputs with invalid characters or common non-URL patterns (e.g., `mailto:`).</li>
                    <li><strong>Protocol Validation:</strong> Can enforce the presence of a protocol, require a valid protocol, and restrict to a list of allowed protocols (e.g., `http`, `https`, `ftp`).</li>
                    <li><strong>Host Validation:</strong>
                        <ul>
                            <li>Requires a hostname by default.</li>
                            <li>Integrates with `FQDNInputValidator` for strict hostname validation (including TLD checks, length, invalid characters).</li>
                            <li>Can disallow `localhost` and IP addresses as hosts.</li>
                            <li>Supports host blacklisting and whitelisting.</li>
                        </ul>
                    </li>
                    <li><strong>Port, Query, and Fragment Control:</strong>
                        <ul>
                            <li>Can require a port to be present.</li>
                            <li>Allows or disallows query parameters (`?key=value`).</li>
                            <li>Allows or disallows URL fragments (`#section`).</li>
                        </ul>
                    </li>
                    <li><strong>Authentication Disallowance:</strong> Can prevent URLs containing username and password (e.g., `http://user:pass@example.com`).</li>
                    <li><strong>Protocol-Relative URL Handling:</strong> Can disallow URLs starting with `//` (protocol-relative).</li>
                    <li><strong>Length Constraints:</strong> Validates overall URL length with configurable minimum and maximum limits.</li>
                    <li><strong>HTML Escaping:</strong> Automatically escapes HTML tags in the URL to prevent XSS vulnerabilities.</li>
                    <li><strong>Custom Regular Expression:</strong> Allows applying a custom regex for specific URL patterns.</li>
                    <li><strong>Inherited Error Management:</strong> Leverages the robust error handling of `FormError` for clear and precise feedback.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate a URL, get the singleton instance of `URLInputValidator`. Then, call the `urlValidator` method, providing the URL string, its field name, and a `URLOptions` object to define specific validation rules.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import {urlInputValidator as urlValidator } from '@wlindabla/form_validator';
            
          
            </code></pre>
            
                <h3>Validating a URL:</h3>
                <pre><code class="language-typescript">import { URLOptions } from '@wlindabla/form_validator'; // Adjust path
            
            // Example 1: Basic valid URL
            let url1 = "https://www.example.com";
            let fieldName1 = "websiteUrl";
            const options1: URLOptions = {}; // Use default options
            await urlValidator.validate(url1, fieldName1, options1);
            
            if (urlValidator.isFieldValid(fieldName1)) {
                console.log(`Validation errors for ${fieldName1}:`, urlValidator.getFieldErrors());
            } else {
                console.log(`${fieldName1} is valid.`); // Output: websiteUrl is valid.
            }
            
            // Example 2: URL requiring protocol and specific allowed protocols
            let url2 = "ftp://fileserver.net/docs";
            let fieldName2 = "fileServerUrl";
            const options2: URLOptions = {
                requireProtocol: true,
                requireValidProtocol: true,
                allowedProtocols: ["ftp"]
            };
            await urlValidator.validate(url2, fieldName2, options2);
            
            if (urlValidator.isFieldValid(fieldName2)) {
                console.log(`Validation errors for ${fieldName2}:`, urlValidator.getFieldErrors());
            } else {
                console.log(`${fieldName2} is valid.`); // Output: fileServerUrl is valid.
            }
            
            // Example 3: URL disallowing IP addresses and query parameters
            let url3 = "http://192.168.1.1/dashboard?user=admin";
            let fieldName3 = "internalToolUrl";
            const options3: URLOptions = {
                allowIP: false,
                allowQueryParams: false
            };
            await urlValidator.validate(url3, fieldName3, options3);
            
            if (urlValidator.isFieldValid(fieldName3)) {
                console.log(`Validation errors for ${fieldName3}:`, urlValidator.getFieldErrors());
                // Output might include: "IP addresses (IPv4 or IPv6) are not allowed in URLs." and "Query parameters "?user=admin" are not allowed."
            }
            
            // Example 4: URL with a blacklisted host
            let url4 = "https://evil.com/malware";
            let fieldName4 = "downloadLink";
            const options4: URLOptions = {
                hostBlacklist: ['evil.com', 'phishing.net']
            };
            await urlValidator.validate(url4, fieldName4, options4);
            
            if (urlValidator.isFieldValid(fieldName4)) {
                console.log(`Validation errors for ${fieldName4}:`, urlValidator.getFieldErrors());
                // Output: { downloadLink: "The hostname "evil.com" is blacklisted." }
            }
            </code></pre>
            
                <h3>Parameters for <code>validate</code>:</h3>
                <ul>
                    <li><code>urlData</code> (<code>string</code>): The URL string to be validated.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the input field, used for error reporting.</li>
                    <li><code>url_options</code> (<code>URLOptions</code>): An object containing the validation rules and configuration for the URL. This includes:
                        <ul>
                            <li><code>allowLocalhost?: boolean</code>: If `true`, `localhost` and `127.0.0.1` are allowed as hostnames. Defaults to `false`.</li>
                            <li><code>allowIP?: boolean</code>: If `true`, IP addresses (IPv4 or IPv6) are allowed as hostnames. Defaults to `false`.</li>
                            <li><code>allowHash?: boolean</code>: If `true`, URL fragments (`#`) are allowed. Defaults to `true`.</li>
                            <li><code>allowQueryParams?: boolean</code>: If `true`, query parameters (`?`) are allowed. Defaults to `true`.</li>
                            <li><code>requirePort?: boolean</code>: If `true`, the URL must include a port number. Defaults to `false`.</li>
                            <li><code>requireHost?: boolean</code>: If `true`, a hostname must be present in the URL. Defaults to `true`.</li>
                            <li><code>maxAllowedLength?: number</code>: The maximum allowed length for the entire URL string. Defaults to `2048`.</li>
                            <li><code>validateLength?: boolean</code>: If `true`, performs length validation on the URL. Defaults to `true`.</li>
                            <li><code>regexValidator?: RegExp</code>: A custom regular expression to apply for overall URL validation.</li>
                            <li><code>allowProtocolRelativeUrls?: boolean</code>: If `true`, URLs starting with `//` (e.g., `//example.com`) are allowed. Defaults to `false`.</li>
                            <li><code>requireValidProtocol?: boolean</code>: If `true`, the URL must use one of the `allowedProtocols`. Defaults to `true`.</li>
                            <li><code>requireProtocol?: boolean</code>: If `true`, a protocol must be present in the URL (e.g., `http://`). Defaults to `false`.</li>
                            <li><code>allowedProtocols?: string[]</code>: An array of allowed protocols (e.g., `["http", "https"]`). Defaults to `["ftp", "https", "http"]`.</li>
                            <li><code>disallowAuth?: boolean</code>: If `true`, URLs with embedded authentication (username:password) are not allowed. Defaults to `false`.</li>
                            <li><code>hostBlacklist?: string[]</code>: An array of hostnames that are not allowed.</li>
                            <li><code>hostWhitelist?: string[]</code>: An array of hostnames that are exclusively allowed. If provided, any host not in this list will be rejected.</li>
                            <li>Any other options inherited from `FQDNInputValidator` (e.g., `ignoreMaxLength`, `allowTrailingDot`, `allowedUnderscores`, `allowNumericTld`, `allowWildcard`).</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    The method returns a Promise that resolves to the current instance of `URLInputValidator`, allowing for asynchronous operations and method chaining.
                </p>
            </section>
            <section id="ChoiceInputValidator">
                <h1>Class <code>ChoiceInputValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `ChoiceInputValidator` class is designed to validate inputs from selection-based fields such as  dropdowns, checkboxes, and radio buttons. It ensures that chosen values are among the allowed options and enforces various constraints like minimum/maximum selections for checkboxes. It extends `FormError` for consistent error management and implements `ChoiceInputValidatorInterface`. This class follows the **singleton pattern**, providing a single, globally accessible instance for efficient choice input validation.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Ensures a unique instance for centralized choice input validation.</li>
                    <li><strong>Select/Dropdown Validation:</strong> Verifies if a single selected value (or multiple selected values) is present in a predefined list of allowed options.</li>
                    <li><strong>Checkbox Group Validation:</strong>
                        <ul>
                            <li>Ensures a minimum and/or maximum number of checkboxes are selected within a group.</li>
                            <li>Can enforce that at least one checkbox is selected if required.</li>
                            <li>Validates that selected checkbox values are within a predefined list of allowed options.</li>
                        </ul>
                    </li>
                    <li><strong>Radio Button Validation:</strong> Can enforce that at least one radio option is selected within a group.</li>
                    <li><strong>HTML Escaping:</strong> Automatically escapes HTML tags in input values to prevent XSS vulnerabilities.</li>
                    <li><strong>Comprehensive Error Messages:</strong> Provides clear and specific error messages for various validation failures.</li>
                    <li><strong>Inherited Error Management:</strong> Leverages the robust error handling of `FormError` for clear and precise feedback.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate choice inputs, first get the singleton instance of `ChoiceInputValidator`. Then, use the appropriate method (`selectValidator`, `checkboxValidator`, or `radioValidator`) based on the type of input you are validating.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { ChoiceInputValidator } from '@wlindabla/form_validator';
            
            const choiceValidator = ChoiceInputValidator.getInstance();
            </code></pre>
            
                <h3>Validating a Select (Dropdown) Input:</h3>
                <pre><code class="language-typescript">import { SelectOptions } from '@wlindabla/form_validator'; // Adjust path
            
            // Example 1: Single select - valid
            let selectedValue1 = "optionA";
            let fieldName1 = "myDropdown";
            const selectOptions1: SelectOptions = {
                optionsChoices: ["optionA", "optionB", "optionC"]
            };
            choiceValidator.selectValidator(selectedValue1, fieldName1, selectOptions1);
            
            if (choiceValidator. isFieldValid(fieldName1)) {
                console.log(`Validation errors for ${fieldName1}:`, choiceValidator.  getFieldErrors());
            } else {
                console.log(`${fieldName1} is valid.`); // Output: myDropdown is valid.
            }
            
            // Example 2: Single select - invalid value
            let selectedValue2 = "optionD";
            let fieldName2 = "myDropdown";
            const selectOptions2: SelectOptions = {
                optionsChoices: ["optionA", "optionB", "optionC"]
            };
            choiceValidator.selectValidator(selectedValue2, fieldName2, selectOptions2);
            
            if (choiceValidator. isFieldValid(fieldName2)) {
                console.log(`Validation errors for ${fieldName2}:`, choiceValidator.  getFieldErrors());
                // Output: { myDropdown: "The selected value "optionD" is not included in the available options: optionA | optionB | optionC" }
            }
            
            // Example 3: Multi-select - valid
            let selectedValues3 = ["optionA", "optionC"];
            let fieldName3 = "multiSelect";
            const selectOptions3: SelectOptions = {
                optionsChoices: ["optionA", "optionB", "optionC"]
            };
            choiceValidator.selectValidator(selectedValues3, fieldName3, selectOptions3);
            
            if (choiceValidator. isFieldValid(fieldName3)) {
                console.log(`Validation errors for ${fieldName3}:`, choiceValidator.  getFieldErrors());
            } else {
                console.log(`${fieldName3} is valid.`); // Output: multiSelect is valid.
            }
            </code></pre>
            
                <h3>Validating a Checkbox Group:</h3>
                <pre><code class="language-typescript">import { OptionsCheckbox } from '@wlindabla/form_validator'; // Adjust path
            
            // Example 1: Checkbox group - required and within min/max
            let checkedCount1 = 2; // User checked 2 options
            let groupName1 = "interests";
            const checkboxOptions1: OptionsCheckbox = {
                required: true,
                minAllowed: 1,
                maxAllowed: 3,
                optionsChoicesCheckbox: ["sports", "music", "reading", "coding"],
                dataChoices: ["sports", "music"] // Values actually checked by user
            };
            choiceValidator.checkboxValidator(checkedCount1, groupName1, checkboxOptions1);
            
            if (choiceValidator. isFieldValid(groupName1)) {
                console.log(`Validation errors for ${groupName1}:`, choiceValidator.  getFieldErrors());
            } else {
                console.log(`${groupName1} is valid.`); // Output: interests is valid.
            }
            
            // Example 2: Checkbox group - not enough selected
            let checkedCount2 = 0;
            let groupName2 = "colors";
            const checkboxOptions2: OptionsCheckbox = {
                required: true,
                minAllowed: 1,
                optionsChoicesCheckbox: ["red", "blue", "green"],
                dataChoices: [] // Nothing checked
            };
            choiceValidator.checkboxValidator(checkedCount2, groupName2, checkboxOptions2);
            
            if (choiceValidator. isFieldValid(groupName2)) {
                console.log(`Validation errors for ${groupName2}:`, choiceValidator.  getFieldErrors());
                // Output: { colors: "Please select at least one option in the "colors" group." }
            }
            
            // Example 3: Checkbox group - too many selected
            let checkedCount3 = 4;
            let groupName3 = "hobbies";
            const checkboxOptions3: OptionsCheckbox = {
                maxAllowed: 3,
                optionsChoicesCheckbox: ["painting", "gaming", "hiking", "cooking", "traveling"],
                dataChoices: ["painting", "gaming", "hiking", "cooking"]
            };
            choiceValidator.checkboxValidator(checkedCount3, groupName3, checkboxOptions3);
            
            if (choiceValidator. isFieldValid(groupName3)) {
                console.log(`Validation errors for ${groupName3}:`, choiceValidator.  getFieldErrors());
                // Output: { hobbies: "You can only select up to 3 options in the "hobbies" group." }
            }
            </code></pre>
            
                <h3>Validating a Radio Button Group:</h3>
                <pre><code class="language-typescript">import { OptionsRadio } from './path/to/YourOptionsInterface'; // Adjust path
            
            // Example 1: Radio group - valid selected
            let selectedValueRadio1 = "yes";
            let groupNameRadio1 = "consent";
            const radioOptions1: OptionsRadio = { required: true };
            choiceValidator.radioValidator(selectedValueRadio1, groupNameRadio1, radioOptions1);
            
            if (choiceValidator. isFieldValid(groupNameRadio1)) {
                console.log(`Validation errors for ${groupNameRadio1}:`, choiceValidator.  getFieldErrors());
            } else {
                console.log(`${groupNameRadio1} is valid.`); // Output: consent is valid.
            }
            
            // Example 2: Radio group - required but no selection
            let selectedValueRadio2 = null;
            let groupNameRadio2 = "gender";
            const radioOptions2: OptionsRadio = { required: true };
            choiceValidator.radioValidator(selectedValueRadio2, groupNameRadio2, radioOptions2);
            
            if (choiceValidator. isFieldValid(groupNameRadio2)) {
                console.log(`Validation errors for ${groupNameRadio2}:`, choiceValidator.  getFieldErrors());
                // Output: { gender: "Please select an option in the "gender" group." }
            }
            </code></pre>
            
                <h3>Parameters for <code>selectValidator</code>:</h3>
                <ul>
                    <li><code>value_index</code> (<code>string | string[]</code>): The value(s) selected by the user from the dropdown. For single-select, it's a string; for multi-select, it's an array of strings.</li>
                    <li><code>targetInputname</code> (<code>string</code>): The name of the select input field.</li>
                    <li><code>options_select</code> (<code>SelectOptions</code>): An object defining the select validation rules. This includes:
                        <ul>
                            <li><code>optionsChoices: string[]</code>: An array of all allowed values for the select options.</li>
                            <li><code>escapestripHtmlAndPhpTags?: boolean</code>: If `true`, HTML and PHP tags are escaped/stripped from the input value(s). Defaults to `true`.</li>
                        </ul>
                    </li>
                </ul>
            
                <h3>Parameters for <code>checkboxValidator</code>:</h3>
                <ul>
                    <li><code>checkCount</code> (<code>number</code>): The number of checkboxes currently selected in the group.</li>
                    <li><code>groupName</code> (<code>string</code>): The name of the checkbox group. This is used for error reporting.</li>
                    <li><code>options_checkbox</code> (<code>OptionsCheckbox</code>, optional): An object defining the checkbox group validation rules. This includes:
                        <ul>
                            <li><code>minAllowed?: number</code>: The minimum number of checkboxes that must be selected.</li>
                            <li><code>maxAllowed?: number</code>: The maximum number of checkboxes that can be selected.</li>
                            <li><code>required?: boolean</code>: If `true`, at least one checkbox must be selected.</li>
                            <li><code>optionsChoicesCheckbox: string[]</code>: An array of all allowed values for the checkboxes in the group.</li>
                            <li><code>dataChoices: string[]</code>: An array of the actual values selected by the user.</li>
                        </ul>
                    </li>
                </ul>
            
                <h3>Parameters for <code>radioValidator</code>:</h3>
                <ul>
                    <li><code>selectedValue</code> (<code>string | null | undefined</code>): The value of the selected radio button, or `null`/`undefined` if none is selected.</li>
                    <li><code>groupName</code> (<code>string</code>): The name of the radio button group. This is used for error reporting.</li>
                    <li><code>options_radio</code> (<code>OptionsRadio</code>, optional): An object defining the radio button group validation rules. This includes:
                        <ul>
                            <li><code>required?: boolean</code>: If `true`, an option must be selected in the radio group.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    All methods return the current instance of `ChoiceInputValidator`, allowing for method chaining.
                </p>
            </section>
            <section id="ImageValidator">
                <h1>Class <code>ImageValidator</code></h1>
            
                <p>
                    The <code>ImageValidator</code> class is a powerful validator designed specifically for image files. It ensures that uploaded images adhere to strict criteria such as allowed file extensions, dimensions (width and height), MIME types, and hexadecimal file signatures. This class is a **singleton**, which guarantees that only one instance of it exists in your application, thereby centralizing image validation logic.
                </p>
                <p>
                    It extends <code>AbstractMediaValidator</code> (which handles common media validations like size and extensions) and implements <code>MediaValidatorInterface</code>, ensuring compliance with defined media validation standards.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Robust Image Validation</strong>: Checks file extensions, dimensions (min/max width and height), and MIME types.</li>
                    <li><strong>Disguised File Detection</strong>: Uses hexadecimal signature validation to ensure the file is truly an image and not a malicious file disguised with an image extension.</li>
                    <li><strong>Singleton Pattern</strong>: Guarantees centralized and efficient management of image validations.</li>
                    <li><strong>Integrated Error Handling</strong>: Inherits error handling capabilities from its parent class, allowing for consistent error reporting.</li>
                    <li><strong>Flexibility</strong>: Supports validation of a single file or a list of files.</li>
                </ul>
            
                ---
            
                <h2>Prerequisites</h2>
                <p>This class depends on the following:</p>
                <ul>
                    <li><code>validateImage</code>: From the external `image-validator` library. Used for image MIME type validation. (Make sure to install it: `npm install image-validator`)</li>
                    <li><code>AbstractMediaValidator</code>: Internal base class for media validation.</li>
                    <li><code>MediaValidatorInterface</code>, <code>OptionsImage</code>: Internal interfaces defining the validation contract and image-specific options.</li>
                </ul>
            
                ---
            
                <h2>Protected Properties</h2>
                <ul>
                    <li>
                        <code>protected readonly signatureHexadecimalFormatFile: Record<string, string[]></code>:
                        <p>A read-only object that stores the starting hexadecimal signatures for various common image formats (JPG, PNG, GIF, BMP, WebP, SVG). These signatures are used to verify the true file type regardless of its extension.</p>
                        <p>Example structure:</p>
                        <pre><code class="language-typescript">{
                jpg: ['ffd8ffe0', ...],
                png: ['89504e47'],
                // ... other formats
            }</code></pre>
                    </li>
                </ul>
            
                <h2>Private Properties</h2>
                <ul>
                    <li><code>private static m_instance_image_validator: ImageValidator;</code>: Holds the single instance of the `ImageValidator` class for the singleton pattern.</li>
                    <li><code>private m_Image: Map<string, File>;</code>: An internal `Map` to potentially store validated `File` objects, indexed by their file name.</li>
                </ul>
            
                ---
            
                <h2>Constructor</h2>
                <p>
                    The constructor of the <code>ImageValidator</code> class is <code>private</code>. You cannot directly create an instance of this class using <code>new ImageValidator()</code>. To obtain an instance, you must use the static method <code>getInstance()</code>, in accordance with the singleton pattern.
                </p>
                <pre><code class="language-typescript">private constructor() {
                super(); // Calls the AbstractMediaValidator constructor
                this.m_Image = new Map<string, File>();
            }
            </code></pre>
            
                ---
            
                <h2>Public Static Method</h2>
            
                <h3><code>static getInstance(): ImageValidator</code></h3>
                <ul>
                    <li><strong>Description</strong>: This is the sole way to obtain an instance of the <code>ImageValidator</code> class. If an instance already exists, it is returned; otherwise, a new instance is created and returned.</li>
                    <li><strong>Returns</strong>: The unique instance of <code>ImageValidator</code>.</li>
                    <li><strong>Usage</strong>:
            <pre><code class="language-typescript">const imageValidator = ImageValidator.getInstance();
            </code></pre>
                    </li>
                </ul>
            
                ---
            
                <h2>Public Instance Methods</h2>
            
                <h3><code>fileValidator(medias: File | FileList, targetInputname: string = 'photofile', optionsimg: OptionsImage = { allowedMimeTypeAccept: ['image/jpeg', 'image/png', 'image/jpg'] }): Promise<this></code></h3>
                <ul>
                    <li><strong>Description</strong>: The main method to validate one or more image files. It orchestrates extension, size, MIME type, and dimension validations.</li>
                    <li><strong>Parameters</strong>:
                        <ul>
                            <li><code>medias</code>: A single `File` object or a `FileList` (for multiple files) to validate.</li>
                            <li><code>targetInputname</code> (optional): The name of the file input field, used for error messages. Defaults to 'photofile'.</li>
                            <li><code>optionsimg</code> (optional): An <a href="#OptionsImage">OptionsImage</a> object specifying validation rules (e.g., `allowedMimeTypeAccept`, `extensions`, `maxsizeFile`, `minHeight`, `maxWidth`, etc.). Default MIME types are `['image/jpeg', 'image/png', 'image/jpg']`.</li>
                        </ul>
                    </li>
                    <li><strong>Returns</strong>: A `Promise` that resolves to the current `ImageValidator` instance, allowing method chaining.</li>
                    <li><strong>How it works</strong>:
                        <ul>
                            <li>Converts `medias` to an array of files if it's a `FileList`.</li>
                            <li>For each file:
                                <ul>
                                    <li>Validates the extension (inherited from <code>AbstractMediaValidator</code>).</li>
                                    <li>Validates the size (inherited from <code>AbstractMediaValidator</code>).</li>
                                    <li>Validates the MIME type via <code>mimeTypeFileValidate</code>.</li>
                                    <li>Validates the file signature via <code>signatureFileValidate</code> to detect disguised files.</li>
                                    <li>If MIME and signature validations succeed, it proceeds with height and width validations via <code>heightValidate</code> and <code>widthValidate</code> (inherited from <code>AbstractMediaValidator</code>).</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            
                ---
            
                <h2>Protected Methods</h2>
            
                <h3><code>protected async signatureFileValidate(file: File, uint8Array?: Uint8Array): Promise<string | null></code></h3>
                <ul>
                    <li><strong>Description</strong>: Validates the file's hexadecimal signature to confirm its true file type and detect disguised files. Reads the beginning of the file to extract its signature and compares it with known signatures.</li>
                    <li><strong>Parameters</strong>:
                        <ul>
                            <li><code>file</code>: The `File` object to validate.</li>
                            <li><code>uint8Array</code> (optional): A `Uint8Array` of the file, if already available (for optimization).</li>
                        </ul>
                    </li>
                    <li><strong>Returns</strong>: A `Promise` that resolves to a `string` error message if the signature is invalid or `null` if validation succeeds.</li>
                    <li><strong>Error Behavior</strong>: In case of file read error or if the file is disguised, an error message is resolved.</li>
                </ul>
            
                <h3><code>protected async mimeTypeFileValidate(file: File, allowedMimeTypeAccept?: string[] | undefined): Promise<string | null></code></h3>
                <ul>
                    <li><strong>Description</strong>: Validates the file's MIME type using the external `image-validator` library.</li>
                    <li><strong>Parameters</strong>:
                        <ul>
                            <li><code>file</code>: The `File` object to validate.</li>
                            <li><code>allowedMimeTypeAccept</code> (optional): An array of allowed MIME types.</li>
                        </ul>
                    </li>
                    <li><strong>Returns</strong>: A `Promise` that resolves to a `string` error message if the MIME type is invalid or `null` if validation succeeds.</li>
                    <li><strong>Note</strong>: This method is more generic for MIME types, while `signatureFileValidate` focuses on detecting disguised files based on binary signature.</li>
                </ul>
            
                <h3><code>protected getContext(): string</code></h3>
                <ul>
                    <li><strong>Description</strong>: Protected method inherited from <code>AbstractMediaValidator</code>. It is implemented here to return the specific validation context (in this case, 'image').</li>
                    <li><strong>Returns</strong>: The string `'image'`.</li>
                </ul>
            
                <h3><code class="language-typescript">protected getFileDimensions(file: File) Promise &lt;{ width: number; height: number; }&gt;</code></h3>
                <ul>
                    <li><strong>Description</strong>: Protected method inherited from <code>AbstractMediaValidator</code>. This image-specific implementation loads the image file into an `Image` object to extract its actual dimensions.</li>
                    <li><strong>Parameters</strong>:
                        <ul>
                            <li><code>file</code>: The `File` object of the image.</li>
                        </ul>
                    </li>
                    <li><strong>Returns</strong>: A `Promise` that resolves to an object `{ width: number; height: number; }` containing the image's dimensions. It rejects in case of an image loading error.</li>
                </ul>
            
                ---
            
                <h2>Private Methods</h2>
            
                <h3><code class="language-typescript">private detecteMimetype(hexasignatureFile: string, uint8Array: Uint8Array): string | null</code></h3>
                <ul>
                    <li><strong>Description</strong>: This internal function determines the true MIME type of an image file based on its hexadecimal signature. For SVGs, it checks the initial textual content.</li>
                    <li><strong>Parameters</strong>:
                        <ul>
                            <li><code>hexasignatureFile</code>: The hexadecimal signature string from the beginning of the image file.</li>
                            <li><code>uint8Array</code>: The `Uint8Array` of the file, necessary for SVG detection.</li>
                        </ul>
                    </li>
                    <li><strong>Returns</strong>: A string representing the detected MIME type (e.g., 'image/jpeg', 'image/png') or `null` if the type cannot be determined.</li>
                </ul>
            
                <h3><code class="language-typescript">private getExtensions(allowedMimeTypes: string[] = ['image/jpeg', 'image/png', 'image/jpg']): string[]</code></h3>
                <ul>
                    <li><strong>Description</strong>: This function converts a list of allowed MIME types into a list of corresponding file extensions.</li>
                    <li><strong>Parameters</strong>:
                        <ul>
                            <li><code>allowedMimeTypes</code> (optional): An array of MIME type strings (default: `['image/jpeg', 'image/png', 'image/jpg']`).</li>
                        </ul>
                    </li>
                    <li><strong>Returns</strong>: An array of strings containing the file extensions (e.g., `['jpeg', 'png', 'jpg']`). It ensures 'jpg' is always included.</li>
                    <li><strong>Note</strong>: This method also updates the allowed extensions via `this.setAllowedExtension()`, an inherited method.</li>
                </ul>
            
                ---
            
                <h2>Usage Example</h2>
                <p>
                    Here's how you might use the <code>ImageValidator</code> class in your application to validate an image upload field.
                </p>
            
                <h3>HTML (Example):</h3>
            <pre><code class="language-html">&lt;form id="imageUploadForm"&gt;
                &lt;label for="profileImage"&gt;Upload a profile image:&lt;/label&gt;
                &lt;input type="file" id="profileImage" name="profileImage" accept="image/*"&gt;
                &lt;div id="profileImageError" style="color: red;"&gt;&lt;/div&gt;
                &lt;button type="submit"&gt;Upload Image&lt;/button&gt;
            &lt;/form&gt;
            </code></pre>
            
                <h3>TypeScript (Example):</h3>
            <pre><code class="language-typescript">import { ImageValidator,OptionsImage } from '@wlindabla/form_validator' // Adjust path 
            const imageValidator = ImageValidator.getInstance();
            
            document.getElementById('imageUploadForm')?.addEventListener('submit', async function (event) {
                event.preventDefault(); // Prevent default form submission
            
                const fileInput = document.getElementById('profileImage') as HTMLInputElement;
                const errorDiv = document.getElementById('profileImageError') as HTMLDivElement;
            
                errorDiv.textContent = ''; // Reset error messages
                imageValidator.clearErrors(); // Clear previous validator errors
            
                if (!fileInput.files || fileInput.files.length === 0) {
                    errorDiv.textContent = 'Please select an image to upload.';
                    return;
                }
            
                const imageFile = fileInput.files[0];
                const options: OptionsImage = {
                    allowedMimeTypeAccept: ['image/jpeg', 'image/png', 'image/webp'],
                    maxsizeFile: 2, // 2 MiB
                    unityMaxSizeFile: 'MiB',
                    minWidth: 100, // Minimum 100px width
                    minHeight: 100, // Minimum 100px height
                    maxWidth: 1000, // Maximum 1000px width
                    maxHeight: 1000, // Maximum 1000px height
                    extensions: ['jpeg', 'png', 'webp'], // Explicitly allowed extensions
                    errorMessageInput: "The image file is invalid or does not meet the required criteria."
                };
            
                try {
                    await imageValidator.validate(imageFile, 'profileImage', options);
            
                    if (imageValidator.hasErrors()) {
                        const errors = imageValidator.  getFieldErrors();
                        // Display the first error found for 'profileImage'
                        if (errors['profileImage']) {
                            errorDiv.textContent = errors['profileImage'];
                        } else {
                            // If the error is not directly related to targetInputname, inspect further
                            errorDiv.textContent = 'Image validation errors: ' + Object.values(errors).join(', ');
                        }
                        console.error("Validation failed:", errors);
                    } else {
                        alert('Image validated successfully! Ready for upload.');
                        console.log('Image validated:', imageFile.name, 'Type:', imageFile.type, 'Size:', imageFile.size);
                        // Here, you can proceed with sending the file to the server
                    }
                } catch (error) {
                    console.error("An unexpected error occurred during validation:", error);
                    errorDiv.textContent = 'An unexpected error occurred.';
                }
            });
            </code>
            </pre>
            </section>
            <section id="DocumentValidator">
                <h1>Class <code>DocumentValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `DocumentValidator` class specializes in validating document files (e.g., PDF, Word, Excel, TXT, CSV) uploaded through web forms. It ensures that uploaded files match expected file types and can perform signature-based validation for enhanced security and integrity checks. This validator extends `AbstractMediaValidator` for common media validation functionalities and implements `MediaValidatorInterface`. As a **singleton**, it provides a single, efficient instance for all your document validation needs.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Ensures a unique instance for centralized document validation.</li>
                    <li><strong>MIME Type Validation:</strong> Checks the file's MIME type against a predefined list of allowed document types.</li>
                    <li><strong>File Extension Validation:</strong> Verifies that the file's extension is appropriate for the detected MIME type.</li>
                    <li><strong>File Signature (Magic Number) Validation:</strong> Performs a deeper check by reading the file's initial bytes (hexadecimal signature) to confirm its true format, mitigating cases where files are merely renamed.</li>
                    <li><strong>Support for Common Document Types:</strong> Pre-configured to validate PDFs, Microsoft Word (DOC, DOCX), Excel (XLS, XLSX), OpenDocument Text (ODT), OpenDocument Spreadsheet (ODS), plain text (TXT), and CSV files.</li>
                    <li><strong>Configurable Allowed Types:</strong> Allows customizing the list of accepted MIME types.</li>
                    <li><strong>Inherited from `AbstractMediaValidator`:</strong> Benefits from shared logic for handling multiple files and reporting errors.</li>
                    <li><strong>Comprehensive Error Reporting:</strong> Provides detailed error messages if a file fails validation, including the file name and specific reason.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate document files, first get the singleton instance of `DocumentValidator`. Then, call the `fileValidator` method, providing the `File` object(s) (or `FileList`), an optional input name, and an `OptionsFile` object to define specific validation rules like allowed MIME types.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { documentValidator } from '@wlindabla/form_validator';
            
           
            </code></pre>
            
                <h3>Validating Document Files:</h3>
                <pre><code class="language-typescript">import { OptionsFile } from '@wlindabla/form_validator'; // Adjust path
            
            // Assume 'fileInput' is an HTML input element of type 'file'
            const fileInput = document.getElementById('documentUpload') as HTMLInputElement;
            
            // Simulate a file selection
            const mockPdfFile = new File(['%PDF-1.4\n...'], 'document.pdf', { type: 'application/pdf' });
            const mockDocxFile = new File(['PK\x03\x04...'], 'report.docx', { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
            const mockInvalidFile = new File(['Fake content'], 'image.jpg', { type: 'image/jpeg' }); // This should fail
            
            // Example 1: Validating a single PDF file
            const options1: OptionsFile = {
                allowedMimeTypeAccept: ['application/pdf']
            };
            await documentValidator.validate(mockPdfFile, 'userDocument', options1);
            
            if (documentValidator. isFieldValid('userDocument')) {
                console.log('PDF Validation Error:', documentValidator.  getFieldErrors());
            } else {
                console.log('PDF is valid.'); // Output: PDF is valid.
            }
            
            // Example 2: Validating multiple document files (PDF and DOCX)
            const fileList = new DataTransfer();
            fileList.items.add(mockPdfFile);
            fileList.items.add(mockDocxFile);
            // fileInput.files = fileList.files; // Assign to a real input if needed
            
            const options2: OptionsFile = {
                allowedMimeTypeAccept: [
                    'application/pdf',
                    'application/msword',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
                ]
            };
            await documentValidator.validate(fileList.files, 'uploadDocuments', options2);
            
            if (documentValidator. isFieldValid('uploadDocuments')) {
                console.log('Multiple Docs Validation Errors:', documentValidator.  getFieldErrors());
            } else {
                console.log('All documents are valid.'); // Output: All documents are valid.
            }
            
            // Example 3: Validating with an invalid file (wrong MIME type or signature)
            const options3: OptionsFile = {
                allowedMimeTypeAccept: ['application/pdf', 'application/msword']
            };
            await documentValidator.validate(mockInvalidFile, 'invoice', options3);
            
            if (documentValidator. isFieldValid('invoice')) {
                console.log('Invalid File Error:', documentValidator.  getFieldErrors());
                // Output: Invalid File Error: { invoice: ["Invalid extension for file image.jpg. Only PDF, Word are allowed."] }
                // Or a signature error if the extension was allowed but content didn't match: "Invalid PDF file signature for file image.jpg."
            }
            </code></pre>
            
                <h3>Parameters for <code>validate</code>:</h3>
                <ul>
                    <li><code>medias</code> (<code>File | FileList</code>): The file(s) to be validated. This can be a single `File` object or a `FileList` object (e.g., from an `<input type="file" multiple>`).</li>
                    <li><code>targetInputname</code> (<code>string</code>, optional): The name of the input field or a custom identifier for reporting errors. Defaults to `'doc'`.</li>
                    <li><code>optionsdoc</code> (<code>OptionsFile</code>): An object containing the validation rules for the documents. This includes:
                        <ul>
                            <li><code>allowedMimeTypeAccept?: string[]</code>: An array of MIME types that are explicitly allowed. If not provided, a default set of common document MIME types (PDF, Word, Excel, etc.) will be used.</li>
                            <li>Other options inherited from `AbstractMediaValidator` might also be available (e.g., `minFileSize`, `maxFileSize`).</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    The method returns a Promise that resolves to the current instance of `DocumentValidator`, allowing for asynchronous file reading and method chaining.
                </p>
            </section>
            <section id="VideoValidator">
                <h1>Class <code>VideoValidator</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `VideoValidator` class is dedicated to validating video files uploaded through web forms. It provides comprehensive checks including file extension, size, MIME type, and importantly, video metadata such as dimensions (width, height) and duration. This validator extends `AbstractMediaValidator` for common media validation functionalities and implements `MediaValidatorInterface`. Following the **singleton pattern**, it ensures a single, efficient instance for all your video validation requirements.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Singleton Pattern:</strong> Guarantees a unique instance for centralized video validation.</li>
                    <li><strong>File Extension Validation:</strong> Checks the file's extension against a list of allowed video formats (e.g., MP4, MKV).</li>
                    <li><strong>File Size Validation:</strong> Ensures the video file does not exceed a specified maximum size, with support for different units (KiB, MiB, GiB).</li>
                    <li><strong>MIME Type Validation:</strong> Verifies the file's MIME type against a list of accepted video MIME types.</li>
                    <li><strong>Metadata Validation:</strong> Crucially, it can validate video dimensions (minimum/maximum width and height) and duration, ensuring the video meets specific playback requirements.</li>
                    <li><strong>Configurable Options:</strong> Allows extensive customization of allowed extensions, MIME types, file size limits, and metadata constraints.</li>
                    <li><strong>Inherited from `AbstractMediaValidator`:</strong> Benefits from shared logic for handling multiple files and robust error reporting.</li>
                    <li><strong>Detailed Error Reporting:</strong> Provides specific error messages for various validation failures, including file name and the nature of the issue (e.g., invalid extension, oversized, bad MIME type, metadata mismatch).</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    To validate video files, first get the singleton instance of `VideoValidator`. Then, call the `fileValidator` method, providing the `File` object(s) (or `FileList`), an optional input name, and an `OptionsMediaVideo` object to define specific validation rules.
                </p>
            
                <h3>Getting an Instance:</h3>
                <pre><code class="language-typescript">import { videoValidator } from '@wlindabla/form_validator';
            
          
            </code></pre>
            
                <h3>Validating Video Files:</h3>
                <pre><code class="language-typescript">import { OptionsMediaVideo } from '@wlindabla/form_validator'; // Adjust path
            
            // Assume 'videoInput' is an HTML input element of type 'file'
            const videoInput = document.getElementById('videoUpload') as HTMLInputElement;
            
            // Simulate a file selection (You'd get actual files from an input event)
            // Note: Metadata validation (dimensions, duration) typically requires reading the file,
            // which is abstracted away by the internal implementation. For a true test, use actual File objects.
            const mockVideoFile = new File(['mock video content'], 'my_movie.mp4', { type: 'video/mp4' });
            const mockTooLargeVideoFile = new File(new ArrayBuffer(12 * 1024 * 1024), 'large_video.mp4', { type: 'video/mp4' }); // 12 MiB
            
            // Example 1: Validating a single MP4 video file with default options (max 5 MiB)
            const options1: OptionsMediaVideo = {}; // Using default options
            await videoValidator.validate(mockVideoFile, 'userVideo', options1);
            
            if (videoValidator. isFieldValid('userVideo')) {
                console.log('Video Validation Error:', videoValidator.  getFieldErrors());
            } else {
                console.log('Video is valid.'); // Output: Video is valid.
            }
            
            // Example 2: Validating a video with custom size and allowed extensions
            const options2: OptionsMediaVideo = {
                extensions: ['webm', 'avi'],
                allowedMimeTypeAccept: ['video/webm', 'video/x-msvideo'],
                maxsizeFile: 20, // Max 20 MiB
                unityMaxSizeFile: 'MiB'
            };
            // const mockWebmFile = new File(['mock webm content'], 'my_clip.webm', { type: 'video/webm' });
            // await videoValidator.validate(mockWebmFile, 'webmVideo', options2);
            // ... check errors
            
            // Example 3: Validating a video with metadata requirements (min dimensions, max duration)
            // IMPORTANT: Actual metadata validation would depend on external libraries
            // or browser APIs capable of parsing video streams to get dimensions/duration.
            // The example below assumes the internal `metadataValidate` correctly handles this.
            const options3: OptionsMediaVideo = {
                minWidth: 640,
                minHeight: 480,
                maxWidth: 1920,
                maxHeight: 1080,
                maxDuration: 300, // seconds (5 minutes)
                extensions: ['mp4'],
                allowedMimeTypeAccept: ['video/mp4']
            };
            // const mockHighResShortVideo = new File(['...'], 'holiday.mp4', { type: 'video/mp4' }); // Assume 1280x720, 60s
            // await videoValidator.validate(mockHighResShortVideo, 'hdVideo', options3);
            // ... check errors
            
            // Example 4: Validating a video that is too large
            const options4: OptionsMediaVideo = {
                maxsizeFile: 10, // Max 10 MiB
                unityMaxSizeFile: 'MiB'
            };
            await videoValidator.validate(mockTooLargeVideoFile, 'largeVideo', options4);
            
            if (videoValidator. isFieldValid('largeVideo')) {
                console.log('Large Video Validation Error:', videoValidator.  getFieldErrors());
                // Output: { largeVideo: ["File large_video.mp4 exceeds maximum allowed size of 10 MiB."] }
            }
            </code></pre>
            
                <h3>Parameters for <code>validate</code>:</h3>
                <ul>
                    <li><code>medias</code> (<code>File | FileList</code>): The video file(s) to be validated. This can be a single `File` object or a `FileList` object (e.g., from an `<input type="file" multiple>`).</li>
                    <li><code>targetInputname</code> (<code>string</code>, optional): The name of the input field or a custom identifier for reporting errors. Defaults to `'videofile'`.</li>
                    <li><code>optionsmedia</code> (<code>OptionsMediaVideo</code>, optional): An object containing the validation rules for the videos. This includes:
                        <ul>
                            <li><code>extensions?: string[]</code>: An array of allowed file extensions (e.g., `['mp4', 'webm']`). Defaults to common video extensions.</li>
                            <li><code>allowedMimeTypeAccept?: string[]</code>: An array of allowed MIME types (e.g., `['video/mp4', 'video/webm']`). Defaults to common video MIME types.</li>
                            <li><code>maxsizeFile?: number</code>: The maximum allowed file size. Defaults to `5`.</li>
                            <li><code>unityMaxSizeFile?: "KiB" | "MiB" | "GiB"`: The unit for `maxsizeFile`. Defaults to `"MiB"`.</li>
                            <li><code>minWidth?: number</code>: Minimum allowed video width in pixels.</li>
                            <li><code>maxWidth?: number</code>: Maximum allowed video width in pixels.</li>
                            <li><code>minHeight?: number</code>: Minimum allowed video height in pixels.</li>
                            <li><code>maxHeight?: number</code>: Maximum allowed video height in pixels.</li>
                            <li><code>minDuration?: number</code>: Minimum allowed video duration in seconds.</li>
                            <li><code>maxDuration?: number</code>: Maximum allowed video duration in seconds.</li>
                            <li>Other options inherited from `AbstractMediaValidator` might also be available.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    The method returns a Promise that resolves to the current instance of `VideoValidator`, allowing for asynchronous file reading and method chaining.
                </p>
            </section>
            <section id="FieldInputController">
                <h1>Class <code>FieldInputController</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>
            
                <p>
                    The `FieldInputController` class provides a dynamic and intelligent way to validate individual form input fields (excluding file inputs which are handled by `FileValidator`). It automatically infers validation rules based on HTML attributes present on the input elements, making it incredibly flexible and easy to use without extensive JavaScript configuration. It extends `AbstractFieldInputController`
                     for shared functionality and implements `FormChildrenValidateInterface` for consistent interaction.
                </p>
            
                ---
            
                <h2>Key Features:</h2>
                <ul>
                    <li><strong>Automatic Rule Inference:</strong> Automatically detects validation rules (e.g., `minlength`, `maxlength`, `required`, `pattern`, `data-*` attributes) directly from the HTML attributes of the input field.</li>
                    <li><strong>Supports Various Input Types:</strong> Handles a wide range of input types including:
                        <ul>
                            <li>Text fields (`text`, `tel`, `textarea`)</li>
                            <li>Password fields</li>
                            <li>Number fields</li>
                            <li>Date fields</li>
                            <li>URL fields</li>
                            <li>Select dropdowns</li>
                            <li>Checkboxes</li>
                            <li>Radio buttons</li>
                            <li>Image, Document, and Video (file input types, with options inferred from attributes)</li>
                        </ul>
                    </li>
                    <li><strong>Integrated Validation Logic:</strong> Uses internal validator instances (like `formInputValidator`) to perform the actual validation checks based on the inferred options.</li>
                    <li><strong>Error Handling Integration:</strong> Connects with the `FormErrorInterface` to manage and retrieve validation errors for the specific field.</li>
                    <li><strong>Event-Driven Validation:</strong> Provides methods to define which events trigger validation and error clearing.</li>
                    <li><strong>Flexible Configuration:</strong> Allows overriding inferred options by providing explicit `OptionsValidate` during instantiation.</li>
                    <li><strong>Checkbox and Radio Group Management:</strong> Enforces proper HTML structure for checkbox and radio button groups by requiring them to be wrapped in a container with a matching `id` attribute.</li>
                </ul>
            
                ---
            
                <h2>Usage:</h2>
                <p>
                    The primary purpose of `FieldInputController` is to encapsulate the validation logic for a single HTML form element. You typically instantiate this class for each input field you want to validate within a larger form validation system.
                </p>
            
                <h3>Constructor:</h3>
                <pre><code class="language-typescript">new FieldInputController(childrenInput: HTMLFormChildrenElement, optionsValidate?: OptionsValidate)
            </code></pre>
                <p>
                    Initializes a new instance of the validator for a specific form input field.
                </p>
                <ul>
                    <li>`childrenInput` (`HTMLFormChildrenElement`): The jQuery-wrapped HTML element (e.g., `&lt;input&gt;`, `&lt;textarea&gt;`, `&lt;select&gt;`) to be validated.</li>
                    <li>`optionsValidate` (`OptionsValidate`, optional): An object to explicitly define validation rules, overriding any inferred from HTML attributes.</li>
                </ul>
            
                <h3>Public Methods:</h3>
            
                <h4>`validate(): Promise&lt;void&gt;`</h4>
                <p>
                    Executes the validation logic for the associated form input field. This method automatically determines the appropriate validation rules based on the input's type and its HTML attributes, then applies them using the `formInputValidator`. It's an asynchronous method, making it suitable for operations that might involve file reading or other async tasks (e.g., for file inputs, though the core logic for non-file inputs is synchronous).
                </p>
                <pre><code class="language-typescript">// Assuming 'myInputField' is a jQuery object representing an HTML input element
            const myInputField = $('input[name="username"]');
            const fieldValidator = new FieldInputController(myInputField);
            
            // Trigger validation for the field
            await fieldValidator.validate();
            
            // After validation, you can check if it's valid
            if (fieldValidator.isValid()) {
                console.log('Field is valid!');
            } else {
                console.log('Field has errors:', fieldValidator.getFormError().  getFieldErrors());
            }
            </code></pre>
            
                <h4>`isValid(): boolean`</h4>
                <p>
                    Checks whether the input field currently has any validation errors. It returns `true` if no errors are present, `false` otherwise.
                </p>
                <pre><code class="language-typescript">const fieldValidator = new FieldInputController($('input[name="email"]'));
            await fieldValidator.validate(); // Run validation first
            
            if (fieldValidator.isValid()) {
                console.log('Email is correctly formatted.');
            } else {
                console.log('Email has issues.');
            }
            </code></pre>
            
                <h4>`getFormError(): FormErrorInterface`</h4>
                <p>
                    Retrieves the `FormErrorInterface` instance associated with this input field. This instance holds all validation error messages for the field.
                </p>
                <pre><code class="language-typescript">const fieldValidator = new FormChildrenValidate($('input[name="password"]'));
            await fieldValidator.validate();
            
            const errors = fieldValidator.getFormError().  getFieldErrors();
            if (errors) {
                console.log('Password errors:', errors);
            }
            </code></pre>
            
                <h4>`getOptionsValidate(): OptionsValidate`</h4>
                <p>
                    Returns the `OptionsValidate` object currently being used for validation. If options were not explicitly provided in the constructor, this method will infer them from the input's HTML attributes (e.g., `minlength`, `maxlength`, `required`, `pattern`, `data-*` attributes) the first time it's called.
                </p>
                <pre><code class="language-typescript">const fieldValidator = new FormChildrenValidate($('input[name="age"]'));
            const currentOptions = fieldValidator.getOptionsValidate();
            console.log('Validation options for age:', currentOptions);
            // Output might include { typeInput: 'number', min: 18, max: 120 } if inferred from HTML
            </code></pre>
            
                <h4>`eventValidate(): EventValidate`</h4>
                <p>
                    Returns the event type (e.g., `'blur'`, `'change'`) that should trigger validation for this field. This value is typically inferred from a `data-event-validate` HTML attribute on the input, or defaults to a standard event.
                </p>
                <pre><code class="language-typescript">const fieldValidator = new FormChildrenValidate($('input[name="username"]'));
            const validationEvent = fieldValidator.eventValidate();
            console.log(`This field should validate on: ${validationEvent}`); // e.g., 'blur' or 'input'
            </code></pre>
            
                <h4>`eventClearError(): EventValidate`</h4>
                <p>
                    Returns the event type that should trigger the clearing of validation errors for this field. This value is typically inferred from a `data-event-clear-error` HTML attribute on the input, or defaults to `'change'`.
                </p>
                <pre><code class="language-typescript">const fieldValidator = new FormChildrenValidate($('input[name="username"]'));
            const clearErrorEvent = fieldValidator.eventClearError();
            console.log(`Errors for this field should clear on: ${clearErrorEvent}`); // e.g., 'change'
            </code></pre>
            
                <h4>`clearErrorField(): void`</h4>
                <p>
                    Clears any visual error states and associated messages for the field. This method is usually called when the user starts typing again after an error, or when validation passes.
                </p>
                <pre><code class="language-typescript">const fieldValidator = new FormChildrenValidate($('input[name="email"]'));
            // Simulate an error
            // fieldValidator.getFormError().setValidatorStatus(false, 'Invalid email', 'email'); 
            
            // Clear the error
            fieldValidator.clearErrorField();
            console.log('Error message for email field should now be cleared.');
            </code></pre>
            
                ---
            
                <h2>HTML Attribute Inference Examples:</h2>
                <p>
                    `FormChildrenValidate` is designed to work seamlessly with standard HTML5 attributes and custom `data-*` attributes for defining validation rules. Below are examples of how various HTML attributes are interpreted:
                </p>
            
                <h3>Text/Tel/Textarea Inputs:</h3>
                <pre><code class="language-html">&lt;input type="text" name="username" minlength="3" maxlength="20" required pattern="[a-zA-Z0-9]+" data-error-message-input="Username must be alphanumeric." data-escapestrip-html-and-php-tags="true" data-eg-await="john.doe"&gt;
            
            &lt;textarea name="comments" minlength="10" maxlength="500" data-escapestrip-html-and-php-tags="true"&gt;&lt;/textarea&gt;
            </code></pre>
                <ul>
                    <li>`minlength`, `maxlength`: Sets minimum and maximum allowed input length.</li>
                    <li>`required`: Marks the field as mandatory.</li>
                    <li>`pattern`: Provides a regular expression for value validation.</li>
                    <li>`data-error-message-input`: Custom error message.</li>
                    <li>`data-escapestrip-html-and-php-tags`: If `true`, HTML/PHP tags in the input are stripped.</li>
                    <li>`data-eg-await`: An example value to display in error messages.</li>
                </ul>
            
                <h3>Password Inputs:</h3>
                <pre><code class="language-html">&lt;input type="password" name="newPassword" minlength="8" data-min-uppercase="1" data-min-number="1" data-symbol-allow="true" data-enable-scoring="true"&gt;
            </code></pre>
                <ul>
                    <li>`minlength`, `maxlength`, `required`: Same as text inputs.</li>
                    <li>`data-upper-case-allow`, `data-lower-case-allow`, `data-symbol-allow`, `data-number-allow`, `data-puntuation-allow`: Allow/disallow specific character types.</li>
                    <li>`data-min-uppercase`, `data-min-lowercase`, `data-min-number`, `data-min-symbol`: Minimum count for character types.</li>
                    <li>`data-enable-scoring`: Enables password strength scoring (if supported by underlying validator).</li>
                    <li>`data-custom-upper-regex`, etc.: Custom regex for character types.</li>
                </ul>
            
                <h3>URL Inputs:</h3>
                <pre><code class="language-html">&lt;input type="url" name="website" required data-allowed-protocols="http,https" data-allow-ip="false" data-require-tld="true"&gt;
            </code></pre>
                <ul>
                    <li>`data-allowed-protocols`: Comma-separated list of allowed URL protocols.</li>
                    <li>`data-allow-localhost`, `data-allow-ip`, `data-allow-query-params`, `data-allow-hash`: Boolean flags to control URL components.</li>
                    <li>`data-required-tld`: If `true`, requires a top-level domain.</li>
                </ul>
            
                <h3>Date Inputs:</h3>
                <pre><code class="language-html">&lt;input type="date" name="eventDate" data-format-date="YYYY/MM/DD" data-min-date="2023-01-01" data-allow-future="false"&gt;
            </code></pre>
                <ul>
                    <li>`data-format-date`: Expected date format.</li>
                    <li>`data-min-date`, `data-max-date`: Minimum and maximum allowed dates.</li>
                    <li>`data-allow-future`, `data-allow-past`: Boolean flags to allow/disallow future or past dates.</li>
                </ul>
            
                <h3>Select Inputs:</h3>
                <pre><code class="language-html">&lt;select name="country" data-escapestrip-html-and-php-tags="true"&gt;
                &lt;option value=""&gt;-- Select Country --&lt;/option&gt;
                &lt;option value="US"&gt;United States&lt;/option&gt;
                &lt;option value="CA"&gt;Canada&lt;/option&gt;
            &lt;/select&gt;
            </code></pre>
                <ul>
                    <li>`data-escapestrip-html-and-php-tags`: If `true`, selected option value is stripped. Options values are automatically collected.</li>
                </ul>
            
                <h3>Number Inputs:</h3>
                <pre><code class="language-html">&lt;input type="number" name="quantity" min="1" max="100" step="1"&gt;
            </code></pre>
                <ul>
                    <li>`min`, `max`, `step`: Standard HTML attributes for number validation.</li>
                </ul>
            
                <h3>Checkbox Groups:</h3>
                <pre><code class="language-html">&lt;div id="hobbies" data-min-allowed="1" data-max-allowed="3" required&gt;
                &lt;input type="checkbox" name="hobbies" value="reading"&gt; Reading
                &lt;input type="checkbox" name="hobbies" value="gaming"&gt; Gaming
                &lt;input type="checkbox" name="hobbies" value="hiking"&gt; Hiking
                &lt;input type="checkbox" name="hobbies" value="cooking"&gt; Cooking
            &lt;/div&gt;
            </code></pre>
                <p>
                    **Important:** All checkboxes within a group must be wrapped in a container element (e.g., `&lt;div&gt;`) with an `id` that matches the `name` attribute of the checkboxes.
                </p>
                <ul>
                    <li>Container `id`: Must match the `name` of the checkboxes.</li>
                    <li>`data-min-allowed`, `data-max-allowed`: Minimum and maximum number of selected checkboxes.</li>
                    <li>`required`: If `true`, at least one checkbox must be selected.</li>
                </ul>
            
                <h3>Radio Button Groups:</h3>
                <pre><code class="language-html">&lt;div id="gender" required&gt;
                &lt;input type="radio" name="gender" value="male"&gt; Male
                &lt;input type="radio" name="gender" value="female"&gt; Female
            &lt;/div&gt;
            </code></pre>
                <p>
                    **Important:** All radio buttons within a group must be wrapped in a container element (e.g., `&lt;div&gt;`) with an `id` that matches the `name` attribute of the radio buttons.
                </p>
                <ul>
                    <li>Container `id`: Must match the `name` of the radio buttons.</li>
                    <li>`required`: If `true`, a radio option must be selected.</li>
                </ul>
            
                <h3>File Inputs (Image, Document, Video):</h3>
                <pre><code class="language-html">&lt;input type="file" name="profilePic" accept="image/*" data-maxsize-file="5" data-unity-max-size-file="MiB" data-min-width="100" data-max-height="500"&gt;
            
            &lt;input type="file" name="resume" accept="application/pdf" data-extentions='["pdf","doc"]' data-allowed-mime-type-accept='["application/pdf","application/msword"]'&gt;
            
            &lt;input type="file" name="introVideo" accept="video/mp4" data-duration="60" data-unity-duration-media="seconds" data-min-width="640"&gt;
            </code></pre>
                <ul>
                    <li>`data-maxsize-file`: Maximum file size.</li>
                    <li>`data-unity-max-size-file`: Unit for `maxsize-file` (e.g., "KiB", "MiB", "GiB").</li>
                    <li>`data-extentions`: JSON array of allowed file extensions (e.g., `["pdf","doc"]`).</li>
                    <li>`data-allowed-mime-type-accept`: JSON array of allowed MIME types.</li>
                    <li>For Images (`type="image"`):
                        <ul>
                            <li>`data-min-width`, `data-max-width`: Min/max image width.</li>
                            <li>`data-min-height`, `data-max-height`: Min/max image height.</li>
                        </ul>
                    </li>
                    <li>For Videos (`type="video"`):
                        <ul>
                            <li>`data-duration`: Max duration for video.</li>
                            <li>`data-unity-duration-media`: Unit for `duration` (e.g., "seconds", "minutes").</li>
                            <li>`data-min-width`, `data-max-width`, `data-min-height`, `data-max-height`: Min/max video dimensions.</li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section id="FormValidateController">
                <h1>Class <code>FormValidateController</code></h1>
                <p class="author-info">
                    <strong>Author:</strong> AGBOKOUDJO Franck &lt;franckagbokoudjo301@gmail.com&gt;<br>
                    <strong>Package:</strong> <a href="https://github.com/Agbokoudjo/form_validator" target="_blank">https://github.com/Agbokoudjo/form_validator</a>
                </p>

    <p>
        The `FormValidate` class provides a robust and flexible solution for managing form validation on the frontend. It simplifies the process of integrating validation into HTML forms by automatically identifying form fields, inferring validation rules from HTML attributes, and orchestrating validation across multiple inputs. It's designed to streamline event handling and provide centralized control over form validation, leveraging jQuery for DOM manipulation.
    </p>

    ---

    <h2>Key Features:</h2>
    <ul>
        <li><strong>Automated Field Detection:</strong> Automatically identifies all relevant input, select, and textarea elements within a specified HTML form, excluding common non-validatable types (e.g., hidden, submit).</li>
        <li><strong>Dynamic Validator Instantiation:</strong> On demand, it creates appropriate validator instances (`FormChildrenValidate` for most inputs, or specialized file validators for `type="file"` inputs based on their `media-type` attribute).</li>
        <li><strong>Event-Driven Validation Management:</strong> Categorizes form fields by the DOM event (e.g., `blur`, `input`, `change`, `focus`) that should trigger their validation, based on custom `data-event-validate-*` attributes. This optimizes event listener attachment.</li>
        <li><strong>Batch and Individual Validation:</strong> Supports validating all fields in a form at once or triggering validation for a single, specific field.</li>
        <li><strong>Centralized Error Handling:</strong> Provides mechanisms to clear validation errors for individual fields.</li>
        <li><strong>jQuery Integration:</strong> Built on jQuery for efficient DOM traversal and manipulation.</li>
    </ul>

    ---

    <h2>Usage:</h2>
    <p>
        To use `FormValidateController`, instantiate it by providing a CSS selector for your target form. Once initialized, you can use its methods to trigger validation, access form children, and manage error states.
    </p>

    <h3>Constructor:</h3>
    <pre><code class="language-typescript">constructor(formCssSelector: string = ".form-validate")
</code></pre>
    <p>
        Initializes a new `FormValidateController` instance for a specific HTML form.
    </p>

    <ul>
        <li>`formCssSelector` (`string`, optional): A CSS selector suffix to identify the form. By default, it targets forms with the class `form-validate` (e.g., `<form class="form-validate">`). If no suffix is provided, it attempts to select all `<form>` elements.</li>
        <li><strong>Throws:</strong> An error if no form element is found matching the provided selector.</li>
    </ul>
    <pre><code class="language-typescript">// Example 1: Validate a form with the class 'my-contact-form'
const contactFormValidator = new FormValidateController('.my-contact-form');

// Example 2: Validate all forms on the page (if no specific class is needed)
const allFormsValidator = new FormValidateController('.form-validate');
</code></pre>

    <h3>Public Methods:</h3>

    <h4>`autoValidateAllFields(): Promise&lt;void&gt;`</h4>

    <p>
        Initiates an asynchronous validation process for all applicable fields within the form. It builds a validator instance for each field and then triggers their individual validation.
    </p>
    <pre><code class="language-typescript">const myFormValidator = new FormValidate('.user-registration-form');

// Typically called when the form is submitted
jQuery('.user-registration-form').on('submit', async function(event) {
    event.preventDefault(); // Prevent default form submission
    try {
        await myFormValidator.autoValidateAllFields();
        // If no errors were thrown, the form is valid.
        console.log('All fields are valid! Submitting form...');
        this.submit(); // Programmatically submit the form
    } catch (error) {
        console.error('Form validation failed:', error);
        // Errors are already displayed by individual field validators
    }
});
</code></pre>

<h4>`validateChildrenForm(target: HTMLFormChildrenElement): Promise&lt;void&gt;`</h4>
<p>
    Validates a single specified child field within the form. This is useful for real-time validation (e.g., on `blur` or `input` events) where you only need to check the field currently being interacted with.
</p>
<ul>
    <li>`target` (`HTMLFormChildrenElement`): The jQuery-wrapped HTML input, select, or textarea element to validate.</li>
</ul>
<pre><code class="language-typescript">const myFormValidator = new FormValidateController('.user-profile-form');

// Validate an input field on blur
myFormValidator.idChildrenUsingEventBlur.forEach(id => {
jQuery(`#${id}`).on('blur', async function() {
    await myFormValidator.validateChildrenForm(jQuery(this));
});
});
</code></pre>

<p>
    Constructs and returns an array of `FormChildrenValidateInterface` instances, one for each relevant child input element in the form. This method prepares all field validators but does not trigger their validation. It's primarily used internally but can be accessed if you need to work with all field validator instances directly.
</p>


<h4>`clearErrorDataChildren(target: HTMLFormChildrenElement): void`</h4>
<p>
    Clears any validation errors associated with the specified child field. This is typically used when a user starts re-entering data into a field that previously had an error, removing the error message.
</p>

<ul>
    <li>`target` (`HTMLFormChildrenElement`): The jQuery-wrapped HTML input, select, or textarea element whose errors should be cleared.</li>
</ul>
<pre><code class="language-typescript">const myFormValidator = new FormValidateController('.feedback-form');

// Clear errors on change
myFormValidator.idChildrenUsingEventChange.forEach(id => {
jQuery(`#${id}`).on('change', function() {
    myFormValidator.clearErrorDataChildren(jQuery(this));
});
});
</code></pre>

<h3>Form Children Accessors (with Event-Based Grouping):</h3>
<p>
    These getters provide convenient ways to retrieve specific groups of form fields (identified by their `id` attributes) based on the DOM event that should trigger their validation. This grouping is determined by custom HTML attributes on the input fields.
</p>

<p>
    **Required HTML attributes for event-based grouping:**
</p>
<ul>
    <li>`data-event-validate-blur="blur"`: Field validates on `blur` event.</li>
    <li>`data-event-validate-input="input"`: Field validates on `input` event (for real-time typing validation).</li>
    <li>`data-event-validate-change="change"`: Field validates on `change` event (for select, checkbox, radio).</li>
    <li>`data-event-validate-focus="focus"`: Field validates on `focus` event.</li>
</ul>
<p>
    This setup allows for efficient attachment of event listeners, ensuring that validation logic is only bound to relevant fields for specific events.
</p>

<h4>`childrens: JQuery&lt;HTMLFormChildrenElement&gt;`</h4>
<p>
    Returns a jQuery collection of all input, select, and textarea elements found within the form, excluding types like `hidden`, `submit`, `datetime`, `datetime-local`, `time`, and `month`.
</p>
<pre><code class="language-typescript">const myFormValidator = new FormValidateController('.my-form');
const allVisibleInputs = myFormValidator.childrens;
console.log(`Total relevant fields: ${allVisibleInputs.length}`);
</code></pre>

<h4>`idChildrenUsingEventBlur: string[]`</h4>
<p>
    Returns an array of IDs of child fields that have the `data-event-validate-blur="blur"` attribute.
</p>

<pre><code class="language-typescript">const myFormValidator = new FormValidateController('.my-form');
    myFormValidator.idChildrenUsingEventBlur.forEach(id => {
        console.log(`Field with ID '${id}' will validate on blur.`);
        // Attach event listeners here
        jQuery(`#${id}`).on('blur', async function() {
            await myFormValidator.validateChildrenForm(jQuery(this));
        });
    });
    </code></pre>
    
        <h4>`idChildrenUsingEventInput: string[]`</h4>
        <p>
            Returns an array of IDs of child fields that have the `data-event-validate-input="input"` attribute.
        </p>

    <pre><code class="language-typescript">const myFormValidator = new FormValidateController('.my-form');
        myFormValidator.idChildrenUsingEventInput.forEach(id => {
            console.log(`Field with ID '${id}' will validate on input.`);
        });
        </code></pre>
        
            <h4>`idChildrenUsingEventChange: string[]`</h4>
            <p>
                Returns an array of IDs of child fields that have the `data-event-validate-change="change"` attribute.
            </p>
            <pre><code class="language-typescript">const myFormValidator = new FormValidateController('.my-form');
        myFormValidator.idChildrenUsingEventChange.forEach(id => {
            console.log(`Field with ID '${id}' will validate on change.`);
        });
        </code></pre>
        
            <h4>`idChildrenUsingEventFocus: string[]`</h4>
            <p>
                Returns an array of IDs of child fields that have the `data-event-validate-focus="focus"` attribute.
            </p>
            <pre><code class="language-typescript">const myFormValidator = new FormValidateController('.my-form');
        myFormValidator.idChildrenUsingEventFocus.forEach(id => {
            console.log(`Field with ID '${id}' will validate on focus.`);
        });
        </code></pre>
        
    <p>
        Returns a cached array of IDs for all relevant input, select, and textarea elements within the form. This list is generated during initialization.
    </p>
    <pre><code class="language-typescript">const myFormValidator = new FormValidateController('.my-form');
console.log('All validatable field IDs:', myFormValidator.idChildrens);
</code></pre>

    <h4>`form: JQuery&lt;HTMLFormElement&gt;`</h4>
    <p>
        Returns the jQuery-wrapped HTML form element that this `FormValidate` instance is managing.
    </p>
    <pre><code class="language-typescript">const myFormValidator = new FormValidateController('.my-form');
const formElement = myFormValidator.form;
console.log('Managed form element:', formElement);
</code></pre>

            <h4>`idChildrens: string[]`</h4>
            ---

            <h2>Required Attributes in the Form and on Fields:</h2>
            <p>
                For `FormValidate` to properly function and infer validation rules, ensure your HTML elements have the following attributes:
            </p>
        
            <table class="styled-table">
                <thead>
                    <tr>
                        <th>Attribute Name</th>
                        <th>Where to Add</th>
                        <th>Purpose / Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>`id`</td>
                        <td>On every `&lt;input&gt;`, `&lt;select&gt;`, `&lt;textarea&gt;`</td>
                        <td>Unique identifier used for mapping validators and event listeners. <strong>Crucial for functionality.</strong></td>
                    </tr>
                    <tr>
                        <td>`name`</td>
                        <td>On every `&lt;input&gt;`, `&lt;select&gt;`, `&lt;textarea&gt;`</td>
                        <td>Required for correct form submission and for the validator to identify fields.</td>
                    </tr>
                    <tr>
                        <td>`media-type`</td>
                        <td>On `&lt;input type="file"&gt;` fields</td>
                        <td>Defines the media type for files (`image`, `video`, or `document`) to select the correct specific file validator. <strong>Mandatory for file inputs.</strong></td>
                    </tr>
                    <tr>
                        <td>`data-event-validate-blur`</td>
                        <td>On any field needing `blur` validation</td>
                        <td>Set to `"blur"` to trigger validation when the field loses focus.</td>
                    </tr>
                    <tr>
                        <td>`data-event-validate-input`</td>
                        <td>On any field needing `input` validation</td>
                        <td>Set to `"input"` to trigger real-time validation as the user types.</td>
                    </tr>
                    <tr>
                        <td>`data-event-validate-change`</td>
                        <td>On any field needing `change` validation</td>
                        <td>Set to `"change"` to trigger validation when the field's value changes (common for `select`, `checkbox`, `radio`).</td>
                    </tr>
                    <tr>
                        <td>`data-event-validate-focus`</td>
                        <td>On any field needing `focus` validation</td>
                        <td>Set to `"focus"` to trigger validation when the field gains focus.</td>
                    </tr>
                </tbody>
            </table>
        
            ---
        
    <h2>Example of Usage:</h2>
    <p>
        This example demonstrates how to integrate `FormValidate` into your application using jQuery to listen for validation events and manage error messages.
    </p>
    
<div style="background-color:#fff; color:#000;font-family: Arial, sans-serif; line-height: 1.6; max-width: 900px; margin: 20px auto; padding: 20px; border: 1px solid #ddd;">

    <h1>Documentation Update: Caching Validation Options</h1>

    <p>We've implemented a robust, pluggable caching system to accelerate repeated field validations.</p>

    <hr>

    <h2>1. Integrating an Options Cache Adapter</h2>

    <p>To boost performance and accelerate repetitive field validations, the <strong><code>FormValidateController</code></strong> supports injecting a caching mechanism for field validation options. This avoids the expensive process of re-reading HTML attributes and recalculating options on every validation event.</p>

    <p>The <code>FormValidateController</code> constructor now accepts an optional second argument:</p>

    <pre style=" padding: 10px; border-radius: 5px; overflow-x: auto;"><code>new FormValidateController(selector: string, cacheAdapter?: FieldOptionsValidateCacheAdapterInterface);</code></pre>

    <h3>Architectural Principle: The Adapter Pattern</h3>

    <p>Your library remains <strong>agnostic to external cache technologies</strong> (like Dexie.js, Redis, etc.). Instead, it relies on the <strong>Adapter Pattern</strong>. Any class provided to the constructor must implement the interface contract: <strong><code>FieldOptionsValidateCacheAdapterInterface</code></strong>.</p>

    <p>If no adapter is provided (the default behavior), the value is <code>undefined</code>, and the system operates in its standard mode, calculating options directly from the DOM on demand.</p>

    <hr>

    <h2>2. Default Usage: The Built-in <code>LocalStorageCacheAdapter</code></h2>

    <p>For most applications, you can gain immediate, persistent performance benefits using the built-in default adapter, <strong><code>LocalStorageCacheAdapter</code></strong>.</p>

    <p style="padding-left: 15px; border-left: 3px solid #007bff; ">
        💡 <strong>Key Advantage:</strong> This adapter utilizes the native browser <code>localStorage</code> API. It is included in the library and requires <strong>zero external dependencies</strong>, maintaining your low-dependency philosophy.
    </p>

    <h3>Implementation Example</h3>

    <p>To activate caching, simply instantiate the default adapter and pass it to the controller:</p>

    <pre style="padding: 15px; border-radius: 5px; overflow-x: auto;">
        <code class="language-typescript">// Example of standard usage, now with caching enabled.
import { FormValidateController, LocalStorageCacheAdapter } from '@wlindabla/form_validator'; 
// ... (other imports)

jQuery(function testvalidateInputWithCache() {
  
  // 1. Instantiate the LocalStorage cache adapter
  const cacheAdapter = new LocalStorageCacheAdapter();

  // 2. Initialize FormValidate, injecting the adapter
  const formValidate = new FormValidateController('#form_validate', cacheAdapter);
     const form=formValidate.form
  // 2. Prepare selectors for fields based on their validation events
  //    addHashToIds is a utility function that converts ['id1', 'id2'] to ['#id1', '#id2']
  //    and then joins them into a comma-separated string for jQuery event delegation.
  const idsBlur = addHashToIds(formValidate.idChildrenUsingEventBlur).join(",");
  const idsInput = addHashToIds(formValidate.idChildrenUsingEventInput).join(",");
  const idsChange = addHashToIds(formValidate.idChildrenUsingEventChange).join(",");

  // 3. Attach event listener for 'blur' event to trigger validation
  //    This listener is delegated to the form element to efficiently handle blur events
  //    on multiple input, textarea elements specified by `idsBlur`.
  form.on("blur", `${idsBlur}`, async (event: JQuery.BlurEvent) => {
    const target = event.target;
    // Ensure the event target is an HTML input or textarea element before validating
    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
      // Validate the specific child field that triggered the blur event
      await formValidate.validateChildrenForm(event.target as HTMLFormChildrenElement);
      Logger.log("Blur event triggered validation:", event);
    }
  });

  // 4. Attach event listener for custom 'FieldValidationFailed' event
  //    This event is dispatched by the FormChildrenValidate class when a field fails validation.
  form.on(FieldValidationFailed, (event: JQuery.TriggeredEvent) => {
    // Access the custom event data containing details about the validation failure
    const data = (event.originalEvent as CustomEvent<FieldValidationEventData>).detail;
    // Use a utility function to display the error message in the DOM
    addErrorMessageFieldDom(jQuery(data.targetChildrenForm), data.message);
    Logger.log("Field validation failed:", data);
  });

  // 5. Attach event listener for custom 'FieldValidationSuccess' event
  //    This event is dispatched when a field successfully passes validation.
    form.on(FieldValidationSuccess, (event: JQuery.TriggeredEvent) => {
    const data = (event.originalEvent as CustomEvent<FieldValidationEventData>).detail;
    Logger.log("Field validation succeeded:", data);
  });

  // 6. Attach event listener for 'input' event to clear errors in real-time
  //    This clears the error message as the user types, providing immediate feedback.
    form.on('input', `${idsInput}`, (event: JQuery.Event | any) => {
    const target = event.target;
    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
      if (target) {
        // Use utility functions to clear visual error states and internal error data
        clearErrorInput(jQuery(target));
        formValidate.clearErrorDataChildren(target);
      }
    }
  });

  // 7. Attach event listener for 'change' event to clear errors
  //    Similar to 'input', but typically used for select, checkbox, and radio inputs.
    form.on('change', `${idsChange}`, (event: JQuery.ChangeEvent) => {
    const target = event.target;
    if (target instanceof HTMLInputElement || target instanceof HTMLSelectElement || target instanceof HTMLTextAreaElement) { // Added HTMLSelectElement for completeness
      if (target) {
        clearErrorInput(jQuery(target));
        
      }
    }
    Logger.log("Change event triggered error clearing:", event);
  });

});</code>
    </pre>

    <hr>

    <h2>3. Advanced Usage: Implementing a Custom Adapter</h2>

    <p>If your project requires more robust or specific caching (e.g., using <strong>Dexie.js</strong> for IndexedDB, or a custom API), you must create a class that strictly implements the interface contract.</p>

    <h3>Contract Interface</h3>

    <pre style=" padding: 10px; border-radius: 5px; overflow-x: auto;">
        <code class="language-typescript">export interface FieldOptionsValidateCacheAdapterInterface {
    /** Reads options from the cache. Must be ASYNCHRONOUS. */
    getItem(key: string): Promise&lt;OptionsValidate | undefined&gt;;
    
    /** Writes options to the cache. Must be ASYNCHRONOUS. */
    setItem(key: string, options: OptionsValidate): Promise&lt;void&gt;;
}</code>
    </pre>

    <h3>Custom Implementation Example</h3>

    <pre style="padding: 15px; border-radius: 5px; overflow-x: auto;">
        <code class="language-typescript">// Note: You must manually import and handle any external cache dependencies (like Dexie.js).
class CustomDexieAdapter implements FieldOptionsValidateCacheAdapterInterface {
    
    async getItem(key: string): Promise&lt;OptionsValidate | undefined&gt; {
        // Your logic to read data from Dexie.js
        // ...
    }

    async setItem(key: string, options: OptionsValidate): Promise&lt;void&gt; {
        // Your logic to write data to Dexie.js
        // Recommended: Avoid 'await' on setItem and use .catch() for non-blocking writes.
    }
}

// Initialization with the Custom Adapter
const customCache = new CustomDexieAdapter();
const formValidate = new FormValidateController('#form_advanced', customCache);
// ...</code>
    </pre>

</div>

    <h2>Summary:</h2>
    <p>
        The `FormValidate` class is a central component of the form validation library. It acts as an orchestrator, simplifying complex form validation tasks by:
    </p>
    <ul>
        <li>Intelligently identifying and categorizing form fields.</li>
        <li>Dynamically assigning appropriate validation logic based on HTML attributes.</li>
        <li>Providing easy-to-use methods for triggering validation across the entire form or on individual fields.</li>
        <li>Facilitating efficient event listener management.</li>
        <li>Streamlining the process of managing and clearing validation errors.</li>
    </ul>
    <p>
        By leveraging `FormValidate`, you can implement sophisticated and user-friendly form validation with minimal JavaScript code, keeping your HTML clean and declarative.
    </p>
            </section>
            <section id="TextInputOptions">
                <h2>Options for Simple Text Fields (<code>&lt;input type="text"&gt;</code>, etc.)</h2>
                <p>
                These options apply to generic text input fields.
                </p>
                <h3>Corresponding HTML Attributes:</h3>
                <ul>
                <li>
                <code>max-length="[number]"</code>:
                <p>Sets the **maximum** allowed text length. By default, `255` characters.</p>
                <pre><code class="language-html">&lt;input type="text" max-length="100"&gt;</code></pre>
                </li>
                <li>
                <code>min-length="[number]"</code>:
                <p>Sets the **minimum length** required for the text. By default, `1` character.</p>
                <pre><code class="language-html">&lt;input type="text" min-length="5"&gt;</code></pre>
                </li>
                <li>
                <code>required</code>:
                <p>Indicates whether the field is **required**.</p>
                <pre><code class="language-html">&lt;input type="text" required&gt;</code></pre>
                </li>
                <li>
                <code>data-escapestrip-html-and-php-tags="true/false"</code>:
                <p>If set to <code>"true"</code>, HTML and PHP tags will be escaped/removed from the text.</p>
                <pre><code class="language-html">&lt;input type="text" data-escapestrip-html-and-php-tags="true"&gt;</code></pre>
                </li>
                <li>
                <code>data-error-message-input="[custom message]"</code>:
                <p>A **custom error message** to display if validation fails.</p>
                <pre><code class="language-html">&lt;input type="text" data-error-message-input="Invalid name."&gt;</code></pre>
                </li>
                <li>
                <code>data-eg-await="[expected example]"</code>:
                <p>An example of the expected format of the input, often used in error messages to guide the user.</p>
                <pre><code class="language-html">&lt;input type="text" data-eg-await="e.g., John Doe"&gt;</code></pre>
                </li>
                <li>
                <code>pattern="[regular expression]"</code>: or <code>data-pattern</code>: A regex pattern that the password must match. Use <code>data-pattern</code> for cross-browser compatibility.
                <p>Provides a **custom regular expression** that the input must match. This is one of the most powerful ways to validate specific formats (phone numbers, postal codes, etc.).</p>
                <pre><code class="language-html">&lt;input type="text" pattern="^[0-9]{5}$"&gt;</code></pre>
                </li>
                </ul>
                </section>
            <section id="FQDNOptions">
                <h2>📌 FQDNOptions</h2>
                <p>
                  The <code>FQDNOptions</code> interface extends the basic <code>TextInputOptions</code> and is specifically
                  used to validate Fully Qualified Domain Names (FQDN), like <strong>example.com</strong> or <strong>www.google.fr</strong>.
                  It provides fine-grained control over what constitutes a valid domain name structure.
                </p>
              
                <p><strong>⚠️ Important:</strong> To enable FQDN validation, developers <strong>MUST</strong> add the attribute 
                  <code>data-type="fqdn"</code> to their input element. This allows the validation engine to recognize and apply the correct validator.
                </p>
              
                <h3>🧩 Available Options:</h3>
                <ul>
                  <li>
                    <code>allowWildcard?: boolean</code> <br>
                    <small>If set to <code>false</code>, domains like <code>*.example.com</code> will be rejected.</small>
                  </li>
                  <li>
                    <code>allowNumericTld?: boolean</code> <br>
                    <small>Rejects TLDs that are purely numeric (e.g., <code>domain.123</code>) when set to <code>false</code>.</small>
                  </li>
                  <li>
                    <code>allowedUnderscores?: boolean</code> <br>
                    <small>Allows underscores (<code>_</code>) in domain labels when set to <code>true</code>.</small>
                  </li>
                  <li>
                    <code>requireTLD?: boolean</code> <br>
                    <small>Requires a top-level domain such as <code>.com</code>, <code>.org</code>. If <code>false</code>, domains like <code>localhost</code> are accepted.</small>
                  </li>
                  <li>
                    <code>allowTrailingDot?: boolean</code> <br>
                    <small>Accepts a trailing dot at the end of the domain (e.g., <code>example.com.</code>).</small>
                  </li>
                  <li>
                    <code>ignoreMaxLength?: boolean</code> <br>
                    <small>Disables the maximum length validation of 63 characters per label and 255 characters total.</small>
                  </li>
                </ul>
              
                <h3>✅ Example HTML Input:</h3>
                <pre><code>&lt;input type="text"
                     name="domain"
                     data-type="fqdn"
                     data-error-message-input="Please enter a valid domain."
                     data-allow-wildcard="false"
                     data-allow-numeric-tld="false"
                     data-allowed-underscores="false"
                     data-require-tld="true"
                     data-allow-trailing-dot="false"
                     data-ignore-max-length="false"
                     required /&gt;
                </code></pre>
              
                <h3>🧪 Behavior:</h3>
                <p>The validator will automatically read these attributes and apply FQDN-specific rules when <code>data-type="fqdn"</code> is present. This allows dynamic detection of the correct validator without any manual configuration in your code.</p>
              </section>
              <section id="OptionsValidateTextarea">
                <h2>Options for <code>&lt;textarea&gt;</code> Fields</h2>
              
                <p>
                  These options are extracted from HTML attributes of a <code>&lt;textarea&gt;</code> element and are used to validate textual content in forms.
                </p>
              
                <h3>Supported HTML Attributes:</h3>
                <ul>
              
                  <li>
                    <code>max-length="[number]"</code>:
                    <p>Specifies the <strong>maximum length</strong> allowed for the input. If not set, the default is <code>1000</code> characters.</p>
                    <pre><code class="language-html">&lt;textarea max-length="500"&gt;&lt;/textarea&gt;</code></pre>
                  </li>
              
                  <li>
                    <code>min-length="[number]"</code>:
                    <p>Specifies the <strong>minimum length</strong> required for the input. If not set, the default is <code>10</code> characters.</p>
                    <pre><code class="language-html">&lt;textarea min-length="20"&gt;&lt;/textarea&gt;</code></pre>
                  </li>
              
                  <li>
                    <code>data-escapestrip-html-and-php-tags="true/false"</code>:
                    <p>If set to <code>"true"</code>, all HTML and PHP tags will be stripped or escaped from the content before validation. This helps prevent XSS attacks.</p>
                    <pre><code class="language-html">&lt;textarea data-escapestrip-html-and-php-tags="true"&gt;&lt;/textarea&gt;</code></pre>
                  </li>
              
                  <li>
                    <code>required</code>:
                    <p>Indicates whether the field is <strong>mandatory</strong>. Simply adding <code>required</code> or <code>required="true"</code> makes the field required.</p>
                    <pre><code class="language-html">&lt;textarea required&gt;&lt;/textarea&gt;</code></pre>
                  </li>
              
                  <li>
                    <code>pattern="[regex]"</code> or <code>data-pattern="[regex]"</code>:
                    <p>
                      Defines a <strong>custom regular expression</strong> that the input must match.
                      <br>
                      <strong>Important:</strong> Some browsers <em>do not support</em> the <code>pattern</code> attribute on <code>&lt;textarea&gt;</code>. To ensure full compatibility, use the <code>data-pattern</code> attribute instead.
                    </p>
                    <pre><code class="language-html">&lt;textarea data-pattern="^[A-Za-z0-9\s]+$"&gt;&lt;/textarea&gt;</code></pre>
                  </li>
              
                  <li>
                    <strong>Additional notes:</strong>
                    <ul>
                      <li><code>typeInput</code> is implicitly set to <code>"textarea"</code>.</li>
                      <li><code>errorMessageInput</code> can be customized using <code>data-error-message-input</code>.</li>
                    </ul>
                  </li>
              
                </ul>
              
                <h3>Automatic Detection</h3>
                <p>
                  In order for the correct validator to be invoked, you must set:
                  <br>
                  <code>data-type="textarea"</code> on the HTML element.
                </p>
                <pre><code class="language-html">&lt;textarea data-type="textarea" required data-pattern="^[a-zA-Z\s]+$"&gt;&lt;/textarea&gt;</code></pre>
              
              </section>
              <section id="EventClearError">
                <h2>Option for Error Clearing Event</h2>
                <p>
                This attribute specifies the event that should trigger the clearing of error messages for the form field.
                </p>
                <h3>Corresponding HTML Attribute (on the input element):</h3>
                <ul>
                <li>
                <code>event-clear-error="[event]"</code>:
                <p>Defines the JavaScript event that will reset the field's error state. For example, "change" to react to value changes, "focus" when the user clicks on the field, etc. The default value is "change".</p>
                <pre><code class="language-html">&lt;input type="text" event-clear-error="focus"&gt;</code></pre>
                </li>
                </ul>
                </section>
                <section id="OptionsFile">
                    <h2>Basic File Validation Options (<code>getBaseOptionsValidate</code>)</h2>
                    <p>
                    These options are common to all file types (images, videos, documents, etc.) and are often inherited.
                    </p>
                    <h3>Corresponding HTML Attributes:</h3>
                    <ul>
                    <li>
                    <code>data-extentions="["ext1","ext2",...]"</code>:
                    <p>A JSON array of **allowed file extension strings** (e.g., <code>'["jpg","png","gif"]'</code>). Note that the array must be a valid JSON string.</p>
                    <pre><code class="language-html">&lt;input type="file" data-extentions='["pdf", "docx"]'&gt;</code></pre>
                    </li>
                    <li>
                    <code>data-allowed-mime-type-accept="[mime1],[mime2],..."</code>:
                    <p>A comma-separated list of **allowed MIME types** (e.g., "image/jpeg, image/png").</p>
                    <pre><code class="language-html">&lt;input type="file" data-allowed-mime-type-accept="application/pdf,text/plain"&gt;</code></pre>
                    </li>
                    <li>
                    <code>data-maxsize-file="[number]"</code>:
                    <p>The **maximum size** allowed for the file. Defaults to 2 units (depends on <code>data-unity-max-size-file</code>).</p>
                    <pre><code class="language-html">&lt;input type="file" data-maxsize-file="5"&gt;</code></pre>
                    </li>
                    <li>
                    <code>data-unity-max-size-file="[unit]"</code>:
                    <p>The unit of measurement for the maximum file size (e.g., "KiB", "MiB", "GiB").</p>
                    <pre><code class="language-html">&lt;input type="file" data-unity-max-size-file="MiB"&gt;</code></pre>
                    </li>
                    <li>
                    <code>data-unity-dimensions="[unit]"</code>:
                    <p>The unit of measurement for dimensions (e.g., "pixels", "cm", "mm"). Used primarily for display or advanced calculations. Internal validation typically uses pixels.</p>
                    <pre><code class="language-html">&lt;input type="file" data-unity-dimensions="pixels"&gt;</code></pre>
                    </li>
                    </ul>
                    </section>
<section id="EmailInputOptions">
        <h2>Options for <code>&lt;input type="email"&gt;</code> Fields</h2>
        
        <p>
            These options are extracted from the <code>&lt;input&gt;</code> tag with <code>data-type="email"</code> and used to validate email addresses. It extends from <code>FQDNOptions</code>, meaning all domain validation rules apply as well.
        </p>
        
        <h3>Required Setup</h3>
        <p>
            To activate this validation logic, make sure to include:
            </p>
            <pre><code class="language-html">&lt;input type="text" data-type="email" /&gt;</code></pre>
            <p>This ensures the system routes the validator to <code>EmailInputValidator</code>.</p>
        
        <h3>Supported HTML Attributes:</h3>
        
        <ul>
        
            <li>
            <code>data-allow-utf8-local-part="true/false"</code>:
            <p>Allows UTF-8 characters in the local part (before the <code>@</code>). Default is <code>false</code>.</p>
            <pre><code class="language-html">&lt;input data-allow-utf8-local-part="true"&gt;</code></pre>
            </li>
        
            <li>
            <code>data-allow-ip-domain="true/false"</code>:
            <p>If <code>true</code>, allows email domains in the form of an IP address, e.g., <code>user@[192.168.0.1]</code>. Default is <code>false</code>.</p>
            </li>
        
            <li>
            <code>data-allow-quoted-local="true/false"</code>:
            <p>Allows quoted strings in the local part (e.g. <code>"user.name"@domain.com</code>). Default is <code>false</code>.</p>
            </li>
        
            <li>
            <code>data-ignore-max-length="true/false"</code>:
            <p>Ignore the maximum length of email (254 characters). Default is <code>false</code>.</p>
            </li>
        
            <li>
            <code>data-host-blacklist="domain1.com,domain2.com"</code>:
            <p>Comma-separated list of blacklisted domains. Emails from these domains will be rejected.</p>
            </li>
        
            <li>
            <code>data-host-whitelist="domain1.com,domain2.com"</code>:
            <p>Only emails from these domains will be accepted. Takes precedence over blacklist.</p>
            </li>
        
            <li>
            <code>data-blacklisted-chars="!"</code>:
            <p>List of characters forbidden in the email address (especially the local part). Example: <code>data-blacklisted-chars="!%$"</code></p>
            </li>
        
            <li>
            <code>data-require-display-name="true/false"</code>:
            <p>Requires the email to have a display name like <code>John Doe &lt;john@example.com&gt;</code>. Default is <code>false</code>.</p>
            </li>
        
            <li>
            <code>data-allow-display-name="true/false"</code>:
            <p>Allows display names in email. If <code>false</code>, display names are rejected.</p>
            </li>
        
            <li>
            <strong>Inherited from <code>FQDNOptions</code>:</strong>
            <ul>
                <li><code>data-allow-wildcard</code></li>
                <li><code>data-allow-numeric-tld</code></li>
                <li><code>data-allowed-underscores</code></li>
                <li><code>data-require-tld</code></li>
                <li><code>data-allow-trailing-dot</code></li>
            </ul>
            </li>
        
            <li>
            <code>max-length</code> / <code>min-length</code>:
            <p>Define length constraints on the entire input string.</p>
            </li>
        
            <li>
            <code>required</code>:
            <p>Makes the field mandatory.</p>
            </li>
        
            <li>
            <code>pattern</code> or <code>data-pattern</code>:
            <p>
                Custom regular expression validation. As some browsers don’t support <code>pattern</code> for all input types, use <code>data-pattern</code> for compatibility.
            </p>
            </li>
        
        </ul>
        
        <h3>Example</h3>
        
        <pre><code class="language-html">&lt;input 
        type="text"
        data-type="email"
        required
        min-length="6"
        max-length="254"
        data-allow-ip-domain="true"
        data-host-whitelist="gmail.com,yahoo.com"
        data-blacklisted-chars="!"
        data-error-message-input="Please enter a valid email address"
        /&gt;</code></pre>
</section>
<section id="URLOptions" style="padding: 2rem; border: 1px solid #ddd; border-radius: 8px; background-color: #f9f9f9;">
    <h2 style="color: #333;">URL Field Validation Options</h2>
  
    <p style="font-size: 1rem; color: #444;">
      This section describes the supported <code>&lt;input type="url"&gt;</code> validation options. These are automatically detected by setting the attribute <code>data-type="url"</code> on your input field. These attributes allow full control over the behavior of the URL validator.
    </p>
  
    <h3 style="color: #555; margin-top: 1.5rem;">Required HTML Attribute</h3>
    <ul>
      <li><code>data-type="url"</code> – Triggers the correct validator for URL inputs.</li>
    </ul>
  
    <h3 style="color: #555; margin-top: 1.5rem;">Supported <code>data-*</code> Attributes</h3>
    <ul style="line-height: 1.6;">
      <li><code>data-allowed-protocols</code> – A comma-separated list of allowed protocols (default: <code>https</code>).</li>
      <li><code>data-allow-localhost</code> – Allow <code>localhost</code> domains (default: <code>false</code>).</li>
      <li><code>data-allow-ip</code> – Allow IP addresses as hostnames.</li>
      <li><code>data-allow-query-params</code> – Accept URLs with <code>?key=value</code> queries.</li>
      <li><code>data-allow-hash</code> – Accept URLs with <code>#fragment</code>.</li>
      <li><code>data-validate-length</code> – Enable length validation (default: <code>true</code>).</li>
      <li><code>data-max-allowed-length</code> – Maximum URL length allowed (default: <code>2084</code>).</li>
      <li><code>data-require-port</code> – Require a port (e.g., <code>:3000</code>) in the URL.</li>
      <li><code>data-disallow-auth</code> – Disallow user:pass@host in URLs.</li>
      <li><code>data-allow-protocol-relative-urls</code> – Allow protocol-relative URLs like <code>//example.com</code>.</li>
      <li><code>data-require-host</code> – Require a valid host (e.g., <code>example.com</code>).</li>
      <li><code>data-require-valid-protocol</code> – Only accept URLs with known protocols.</li>
      <li><code>data-require-protocol</code> – Force presence of <code>http://</code> or <code>https://</code>.</li>
      <li><code>data-host-whitelist</code> – A comma-separated list of allowed domains (can include regex).</li>
      <li><code>data-host-blacklist</code> – A comma-separated list of blocked domains.</li>
      <li><code>data-allow-wildcard</code> – Allow wildcards like <code>*.example.com</code>.</li>
      <li><code>data-allow-numeric-tld</code> – Allow numeric TLDs like <code>.123</code>.</li>
      <li><code>data-allowed-underscores</code> – Allow underscores in domains.</li>
      <li><code>data-require-tld</code> – Require a TLD like <code>.com</code>.</li>
      <li><code>data-allow-trailing-dot</code> – Allow URLs that end with a dot.</li>
      <li><code>data-ignore-max-length</code> – Skip FQDN length validations.</li>
      <li><code>data-pattern</code> – Custom regular expression (useful for compatibility with some browsers that ignore <code>pattern</code> on <code>&lt;textarea&gt;</code>).</li>
    </ul>
  
    <h3 style="color: #555; margin-top: 2rem;">Example</h3>
    <pre style="background: #f4f4f4; padding: 1rem; border-radius: 6px; overflow-x: auto;">
  <code class="language-html">
  &lt;input
    type="url"
    name="website"
    data-type="url"
    required
    max-length="2084"
    data-allowed-protocols="https,http"
    data-allow-localhost="true"
    data-allow-query-params="true"
    data-host-blacklist="badsite.com"
    data-error-message-input="Please enter a valid URL!"
    data-validate-length="true"
  /&gt;
  </code>
    </pre>
  
    <p style="margin-top: 1rem; font-style: italic;">
      ⚠️ If you need to ensure compatibility for <code>pattern</code> in older or non-standard browsers, consider using <code>data-pattern</code> instead of the standard <code>pattern</code> attribute.
    </p>
  </section>
  <section id="PassworkRuleOptions" style="padding: 1.5rem; border: 1px solid #ccc; border-radius: 6px; background-color: #fefefe;">
    <h2 style="color: #333;">Password Field Validation Options</h2>
  
    <p>
      These options are extracted from a password input's HTML attributes and determine the password strength and rule validation. The validator is activated when the input field includes <code>data-type="password"</code>.
    </p>
  
    <h3>Supported <code>data-*</code> Attributes:</h3>
    <ul style="line-height: 1.6;">
      <li><code>data-upper-case-allow</code>: Allow uppercase letters (A-Z).</li>
      <li><code>data-lower-case-allow</code>: Allow lowercase letters (a-z).</li>
      <li><code>data-symbol-allow</code>: Allow special symbols (e.g., @, #, $, etc.).</li>
      <li><code>data-number-allow</code>: Allow numeric characters (0-9).</li>
      <li><code>data-puntuation-allow</code>: Allow punctuation characters (e.g., ., !, ?).</li>
      <li><code>data-min-lowercase</code>: Minimum number of lowercase letters required.</li>
      <li><code>data-min-uppercase</code>: Minimum number of uppercase letters required.</li>
      <li><code>data-min-number</code>: Minimum number of numeric characters required.</li>
      <li><code>data-min-symbol</code>: Minimum number of symbols required.</li>
      <li><code>data-enable-scoring</code>: Enable password scoring/strength calculation.</li>
      <li><code>data-custom-upper-regex</code>: Provide a custom regex to match uppercase characters.</li>
      <li><code>data-custom-lower-regex</code>: Provide a custom regex to match lowercase characters.</li>
      <li><code>data-custom-number-regex</code>: Provide a custom regex to match numeric characters.</li>
      <li><code>data-custom-symbol-regex</code>: Provide a custom regex to match special symbols.</li>
      <li><code>data-custom-punctuation-regex</code>: Provide a custom regex to match punctuation characters.</li>
      <li><code>data-error-message-input</code>: Custom error message to display on failure.</li>
      <li><code>required</code>: Makes the field mandatory.</li>
      <li><code>min-length</code>: Minimum allowed character count (default: 8).</li>
      <li><code>max-length</code>: Maximum allowed character count (default: 255).</li>
      <li><code>pattern</code> or <code>data-pattern</code>: A regex pattern that the password must match. Use <code>data-pattern</code> for cross-browser compatibility.</li>
    </ul>
  
    <h3>Example:</h3>
    <pre style="background: #f8f8f8; padding: 1rem; border-radius: 5px;">
  <code class="language-html">
  &lt;input
    type="password"
    name="user_password"
    data-type="password"
    required
    min-length="8"
    max-length="128"
    data-upper-case-allow="true"
    data-lower-case-allow="true"
    data-number-allow="true"
    data-symbol-allow="true"
    data-enable-scoring="true"
    data-error-message-input="Password must include letters, numbers, and symbols."
  /&gt;
  </code>
    </pre>
  
    <p><strong>Note:</strong> For complete validation, it's recommended to define <code>data-type="password"</code> and specify at least <code>min-length</code> and character rules.</p>
  </section>
  <section id="NumberOptions">
    <h2>Number Field Options (<code>&lt;input type="number"&gt;</code>)</h2>
    <p>
    These options define numeric constraints for number input fields. </p>
    <h3>Corresponding HTML Attributes:</h3>
    <ul>
    <li>
    <code>min="[number]"</code>:
    <p>The **minimum numeric value** allowed.</p>
    <pre><code class="language-html">&lt;input type="number" min="0"&gt;</code></pre>
    </li>
    <li>
    <code>max="[number]"</code>:
    <p>The **maximum numeric value** allowed.</p>
    <pre><code class="language-html">&lt;input type="number" max="100"&gt;</code></pre>
    </li>
    <li>
    <code>step="[number]"</code>:
    <p>The **increment/decrement step** allowed. For example, <code>step="0.01"</code> for decimal values.</p>
    <pre><code class="language-html">&lt;input type="number" step="0.5"&gt;</code></pre>
    </li>
    <li>
    <code>pattern="[regular expression]"</code>:  <code>data-pattern</code>: A regex pattern that the password must match. Use <code>data-pattern</code> for cross-browser compatibility.
    <p>Provides a **custom regular expression** that the number must match. Can be used for specific number formats (e.g., only integers, or numbers with a certain number of decimal places).</p>
    <pre><code class="language-html">&lt;input type="number" pattern="^\d+$"&gt;</code></pre>
    </li>
    </ul>
    </section>
    <section id="DateInputOptions" style="padding: 1.5rem; border: 1px solid #ccc; border-radius: 8px; background-color: #fcfcfc;">
        <h2 style="color: #2c3e50;">Date Input Field Validation Options</h2>
        <p>
          The following options are automatically retrieved from the HTML attributes of a <code>&lt;input type="text"&gt;</code> or <code>&lt;input type="date"&gt;</code> element used for date entry.
          To trigger the date validator, include the attribute <code>data-type="date"</code> on your field.
        </p>
      
        <h3>Supported HTML Attributes</h3>
        <ul style="line-height: 1.7;">
          <li><code>data-format-date</code>: Expected format (e.g., <code>YYYY-MM-DD</code>, <code>DD/MM/YYYY</code>).</li>
          <li><code>data-min-date</code>: The earliest valid date (e.g., <code>2000-01-01</code>).</li>
          <li><code>data-max-date</code>: The latest valid date (e.g., <code>2099-12-31</code>).</li>
          <li><code>data-allow-future</code>: Whether dates in the future are allowed (<code>true/false</code>).</li>
          <li><code>data-allow-past</code>: Whether past dates are allowed (<code>true/false</code>).</li>
          <li><code>data-strict-mode</code>: If <code>true</code>, the length must strictly match the format pattern.</li>
          <li><code>data-delimiters</code>: List of allowed delimiters for the date string (e.g., <code>/-</code>, or <code>,</code>).</li>
          <li><code>required</code>: Marks the field as mandatory.</li>
          <li><code>min-length</code>: Minimum character length (default: <code>10</code>).</li>
          <li><code>max-length</code>: Maximum character length (default: <code>21</code>).</li>
          <li><code>data-error-message-input</code>: Custom error message for invalid date input.</li>
          <li><code>pattern</code> or <code>data-pattern</code>: Regex to enforce custom format. Use <code>data-pattern</code> for better browser compatibility.</li>
        </ul>
      
        <h3>HTML Example</h3>
        <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #2980b9;">
      <code>
      &lt;input 
        type="text"
        name="birth_date"
        data-type="date"
        required
        data-format-date="YYYY-MM-DD"
        data-min-date="1990-01-01"
        data-max-date="2025-12-31"
        data-allow-past="true"
        data-allow-future="false"
        data-strict-mode="true"
        data-delimiters="-"
      /&gt;
      </code>
        </pre>
      
        <p style="color: #555;"><strong>Note:</strong> Always use <code>data-type="date"</code> to ensure the validator uses the proper logic for date fields.</p>
      </section>
      <section id="OptionsMediaVideo">
        <h2>Options for Video Files (<code>&lt;input type="file"&gt;</code> for videos)</h2>
        <p>
        These options apply to validations specific to video files. They also include basic file options.
        </p>
        <h3>Corresponding HTML Attributes:</h3>
        <ul>
        <li>
        <code>data-duration="[number]"</code>:
        <p>The **maximum duration** allowed for the video. Defaults to 10 units (depends on <code>data-unity-duration-media</code>).</p>
        <pre><code class="language-html">&lt;input type="file" accept="video/*" data-duration="60" data-unity-duration-media="seconds"&gt;</code></pre>
        </li>
        <li>
        <code>data-min-width="[pixels]"</code>:
        <p>The **minimum width** required in pixels. Defaults to 10.</p>
        <pre><code class="language-html">&lt;input type="file" accept="video/*" data-min-width="640"&gt;</code></pre>
        </li>
        <li>
        <code>data-max-width="[pixels]"</code>:
        <p>The **maximum width** allowed in pixels. Default: `1600`.</p>
        <pre><code class="language-html">&lt;input type="file" accept="video/*" data-max-width="1920"&gt;</code></pre>
        </li>
        <li>
        <code>data-min-height="[pixels]"</code>:
        <p>The **minimum height** required in pixels. Default: `10`.</p>
        <pre><code class="language-html">&lt;input type="file" accept="video/*" data-min-height="480"&gt;</code></pre>
        </li>
        <li>
        <code>data-max-height="[pixels]"</code>:
        <p>The **maximum height** allowed in pixels. Default is `2500`.</p>
        <pre><code class="language-html">&lt;input type="file" accept="video/*" data-max-height="1080"&gt;</code></pre>
        </li>
        <li>
        <code>data-unity-duration-media="[unit]"</code>:
        <p>The unit of measurement for duration (e.g., "seconds", "minutes", "hours").</p>
        <pre><code class="language-html">&lt;input type="file" accept="video/*" data-unity-duration-media="minutes"&gt;</code></pre>
        </li>
        <li>
        **Attributes inherited from <code><a href="#OptionsFile">OptionsFile</a></code> (see next section):**
        <code>data-extentions</code>, <code>data-allowed-mime-type-accept</code>, <code>data-maxsize-file</code>, <code>data-unity-max-size-file</code>, <code>data-unity-dimensions</code>. 
        </li> 
        </ul>
        </section>
        <section id="OptionsImage">
            <h2>Image File Options (<code>&lt;input type="file"&gt;</code> for images)</h2>
            <p>
            These options apply to validations specific to image files. They also include basic file options.
            </p>
            <h3>Corresponding HTML Attributes:</h3>
            <ul>
            <li>
            <code>data-min-width="[pixels]"</code>:
            <p>The **minimum width** required in pixels. Defaults to `10`.</p>
            <pre><code class="language-html">&lt;input type="file" accept="image/*" data-min-width="150"&gt;</code></pre>
            </li>
            <li>
            <code>data-max-width="[pixels]"</code>:
            <p>The **maximum width** allowed in pixels. Default: `1600`.</p>
            <pre><code class="language-html">&lt;input type="file" accept="image/*" data-max-width="800"&gt;</code></pre>
            </li>
            <li>
            <code>data-min-height="[pixels]"</code>:
            <p>The **minimum height** required in pixels. Default: `10`.</p>
            <pre><code class="language-html">&lt;input type="file" accept="image/*" data-min-height="150"&gt;</code></pre>
            </li>
            <li>
            <code>data-max-height="[pixels]"</code>:
            <p>The **maximum height** allowed in pixels. Defaults to `2500`.</p> 
            <pre><code class="language-html">&lt;input type="file" accept="image/*" data-max-height="800"&gt;</code></pre> 
            </li> 
            <li> 
            **Attributes inherited from <code>getBaseOptionsValidate</code> (see next section):** 
            <code>data-extentions</code>, <code>data-allowed-mime-type-accept</code>, <code>data-maxsize-file</code>, <code>data-unity-max-size-file</code>, <code>data-unity-dimensions</code>. 
            </li> 
            </ul>
            </section>
            <section id="TelInputOptions" style="padding: 1.5rem; border: 1px solid #ccc; border-radius: 8px; background-color: #fefefe;">
                <h2 style="color: #2c3e50;">Telephone Input Validation Options</h2>
              
                <p>
                  This validator is intended for validating international phone numbers based on country codes.  
                  To trigger the correct validator logic, you must specify the attribute <code>data-type="tel"</code> in your input field.
                </p>
              
                <h3 style="margin-top: 1rem;">Supported HTML Attributes</h3>
                <ul style="line-height: 1.7;">
                  <li>
                    <code>data-default-country</code>:
                    <p>Defines the default country for the phone number format. Use the <strong>ISO 3166-1 alpha-2</strong> country code (e.g., <code>FR</code>, <code>US</code>, <code>BJ</code>).</p>
                  </li>
              
                  <li>
                    <code>required</code>:
                    <p>If present, the input field must not be empty.</p>
                  </li>
              
                  <li>
                    <code>min-length</code> and <code>max-length</code>:
                    <p>Defines the acceptable character length of the phone number input. If not provided, defaults are used.</p>
                  </li>
              
                  <li>
                    <code>data-error-message-input</code>:
                    <p>Custom message to display in case of validation failure (e.g., "Please enter a valid phone number").</p>
                  </li>
              
                  <li>
                    <code>pattern</code> or <code>data-pattern</code>:
                    <p>
                      Optional regex to override default validation logic. It’s recommended to use
                      <code>data-pattern</code> instead of <code>pattern</code> for compatibility with older browsers.
                    </p>
                  </li>
              
                  <li>
                    <code>data-escapestrip-html-and-php-tags</code>:
                    <p>If <code>true</code>, strips HTML or PHP tags from input before validation (useful for sanitization).</p>
                  </li>
                </ul>
              
                <h3 style="margin-top: 1rem;">Example HTML Usage</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #27ae60;">
              <code>
              &lt;input 
                type="text"
                name="user_phone"
                data-type="tel"
                data-default-country="BJ"
                required
                data-error-message-input="Please enter a valid phone number"
                min-length="8"
                max-length="15"
              /&gt;
              </code>
                </pre>
              
                <h3 style="margin-top: 1rem;">Developer Note</h3>
                <p style="color: #555;">
                  Internally, the validator will use the specified <code>defaultCountry</code> to normalize and validate international numbers.
                  Make sure to integrate a library such as <code>libphonenumber-js</code> or similar if custom validation is required based on region.
                </p>
              </section>
              <section id="SelectOptions" style="padding: 1.5rem; border: 1px solid #ccc; border-radius: 8px; background-color: #fefefe;">
                <h2 style="color: #2c3e50;">Select Field Validation Options</h2>
              
                <p>
                  This section describes the options automatically extracted from a <code>&lt;select&gt;</code> element for validation purposes.
                  The validator checks if the selected value exists in the predefined list of choices.
                </p>
              
                <h3 style="margin-top: 1rem;">Supported HTML Attributes</h3>
              
                <ul style="line-height: 1.7;">
                  <li>
                    <code>&lt;option&gt;</code>:
                    <p>Each option’s <code>value</code> attribute is collected. If <code>value</code> is missing, the option’s text content will be used instead.</p>
                    <pre><code class="language-html">
              &lt;select name="category"&gt;
                &lt;option value="tech"&gt;Tech&lt;/option&gt;
                &lt;option value="science"&gt;Science&lt;/option&gt;
                &lt;option&gt;Other&lt;/option&gt; &lt;!-- Will use text "Other" --&gt;
              &lt;/select&gt;
                    </code></pre>
                  </li>
              
                  <li>
                    <code>data-escapestrip-html-and-php-tags</code>:
                    <p>If set to <code>"true"</code>, any HTML or PHP tags in selected values will be stripped for sanitization.</p>
                    <pre><code class="language-html">
              &lt;select data-escapestrip-html-and-php-tags="true"&gt;...&lt;/select&gt;
                    </code></pre>
                  </li>
                </ul>
              
                <h3 style="margin-top: 1rem;">Expected Output Structure</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #3498db;">
              <code>
              {
                optionsChoices: ['tech', 'science', 'Other'],
                escapestripHtmlAndPhpTags: true
              }
              </code>
                </pre>
              
                <h3 style="margin-top: 1rem;">HTML Example</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #27ae60;">
              <code>
              &lt;select name="subject" data-type="select" data-escapestrip-html-and-php-tags="true"&gt;
                &lt;option value="math"&gt;Mathematics&lt;/option&gt;
                &lt;option value="bio"&gt;Biology&lt;/option&gt;
                &lt;option&gt;Other&lt;/option&gt;
              &lt;/select&gt;
              </code>
                </pre>
              
                <h3 style="margin-top: 1rem;">Developer Note</h3>
                <p style="color: #555;">
                  Internally, the validator collects all valid choices from the options list and verifies if the selected value matches one of them.
                  This is especially useful to prevent tampering with submitted values.
                </p>
              </section>
              <section id="OptionsCheckBox" style="padding: 1.5rem; border: 1px solid #ccc; border-radius: 8px; background-color: #fefefe; margin-bottom: 2rem;">
                <h2 style="color: #2c3e50;">Checkbox Group Validation Options</h2>
              
                <p>
                  These options apply to groups of <code>&lt;input type="checkbox"&gt;</code> elements and define how many items can or must be selected.
                </p>
              
                <h3 style="margin-top: 1rem;">Supported HTML Attributes (Container Level)</h3>
              
                <ul style="line-height: 1.7;">
                  <li>
                    <code>data-max-allowed</code>:
                    <p>Specifies the maximum number of checkboxes that can be selected.</p>
                    <pre><code class="language-html">&lt;div data-max-allowed="3"&gt;...checkboxes...&lt;/div&gt;</code></pre>
                  </li>
              
                  <li>
                    <code>data-min-allowed</code>:
                    <p>Specifies the minimum number of checkboxes that must be selected.</p>
                    <pre><code class="language-html">&lt;div data-min-allowed="1"&gt;...checkboxes...&lt;/div&gt;</code></pre>
                  </li>
              
                  <li>
                    <code>required</code>:
                    <p>Indicates that at least one checkbox must be selected.</p>
                    <pre><code class="language-html">&lt;div required&gt;...checkboxes...&lt;/div&gt;</code></pre>
                  </li>
                </ul>
              
                <h3 style="margin-top: 1rem;">Generated Options Object</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #3498db;">
              <code>
              {
                maxAllowed: 3,
                minAllowed: 1,
                required: true,
                dataChoices: ['value1', 'value2'],
                optionsChoicesCheckbox: ['value1', 'value2', 'value3']
              }
              </code>
                </pre>
              
                <h3 style="margin-top: 1rem;">Example Markup</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #27ae60;">
              <code>
              &lt;div data-type="checkbox" data-min-allowed="1" data-max-allowed="3" required&gt;
                &lt;label&gt;&lt;input type="checkbox" name="topics[]" value="math"&gt; Math&lt;/label&gt;
                &lt;label&gt;&lt;input type="checkbox" name="topics[]" value="bio"&gt; Biology&lt;/label&gt;
                &lt;label&gt;&lt;input type="checkbox" name="topics[]" value="chem"&gt; Chemistry&lt;/label&gt;
              &lt;/div&gt;
              </code>
                </pre>
              </section>
              
              <section id="OptionsRadio" style="padding: 1.5rem; border: 1px solid #ccc; border-radius: 8px; background-color: #fefefe;">
                <h2 style="color: #2c3e50;">Radio Button Group Validation Options</h2>
              
                <p>
                  This option applies to groups of <code>&lt;input type="radio"&gt;</code> and ensures that one option must be selected.
                </p>
              
                <h3 style="margin-top: 1rem;">Supported HTML Attribute</h3>
              
                <ul style="line-height: 1.7;">
                  <li>
                    <code>required</code>:
                    <p>If present, the validator enforces that at least one radio button in the group must be selected.</p>
                    <pre><code class="language-html">&lt;div data-type="radio" required&gt;...radio buttons...&lt;/div&gt;</code></pre>
                  </li>
                </ul>
              
                <h3 style="margin-top: 1rem;">Generated Options Object</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #3498db;">
              <code>
              {
                required: true
              }
              </code>
                </pre>
              
                <h3 style="margin-top: 1rem;">Example Markup</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #27ae60;">
              <code>
              &lt;div data-type="radio" required&gt;
                &lt;label&gt;&lt;input type="radio" name="gender" value="male"&gt; Male&lt;/label&gt;
                &lt;label&gt;&lt;input type="radio" name="gender" value="female"&gt; Female&lt;/label&gt;
              &lt;/div&gt;
              </code>
                </pre>
              </section>
              <section id="OptionsCheckBox" style="padding: 1.5rem; border: 1px solid #ccc; border-radius: 8px; background-color: #fefefe; margin-bottom: 2rem;">
                <h2 style="color: #2c3e50;">Checkbox Group Validation Options</h2>
              
                <p>
                  These options apply to groups of <code>&lt;input type="checkbox"&gt;</code> elements and define how many items can or must be selected.
                </p>
              
                <h3 style="margin-top: 1rem;">Supported HTML Attributes (Container Level)</h3>
              
                <ul style="line-height: 1.7;">
                  <li>
                    <code>data-max-allowed</code>:
                    <p>Specifies the maximum number of checkboxes that can be selected.</p>
                    <pre><code class="language-html">&lt;div data-max-allowed="3"&gt;...checkboxes...&lt;/div&gt;</code></pre>
                  </li>
              
                  <li>
                    <code>data-min-allowed</code>:
                    <p>Specifies the minimum number of checkboxes that must be selected.</p>
                    <pre><code class="language-html">&lt;div data-min-allowed="1"&gt;...checkboxes...&lt;/div&gt;</code></pre>
                  </li>
              
                  <li>
                    <code>required</code>:
                    <p>Indicates that at least one checkbox must be selected.</p>
                    <pre><code class="language-html">&lt;div required&gt;...checkboxes...&lt;/div&gt;</code></pre>
                  </li>
                </ul>
              
                <h3 style="margin-top: 1rem;">Generated Options Object</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #3498db;">
              <code>
              {
                maxAllowed: 3,
                minAllowed: 1,
                required: true,
                dataChoices: ['value1', 'value2'],
                optionsChoicesCheckbox: ['value1', 'value2', 'value3']
              }
              </code>
                </pre>
              
                <h3 style="margin-top: 1rem;">Example Markup</h3>
                <pre style="background-color: #f4f4f4; padding: 1rem; border-left: 4px solid #27ae60;">
              <code>
              &lt;div data-type="checkbox" data-min-allowed="1" data-max-allowed="3" required&gt;
                &lt;label&gt;&lt;input type="checkbox" name="topics[]" value="math"&gt; Math&lt;/label&gt;
                &lt;label&gt;&lt;input type="checkbox" name="topics[]" value="bio"&gt; Biology&lt;/label&gt;
                &lt;label&gt;&lt;input type="checkbox" name="topics[]" value="chem"&gt; Chemistry&lt;/label&gt;
              &lt;/div&gt;
              </code>
                </pre>
              </section>
                                    
        </main>
    </div>
</body>
</html>